
/*
 * Quantum Computing Simulator (QCS) - Single Header Library
 *
 * File: qcs.h
 * Generated: 2025-10-06
 * Author: SegusFaultise / Zakk Wilson-Christian
 * Auto-Generated by bundle.py
 */

/*
 * The MIT License (MIT)
 * * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


#ifndef QCS_SINGLE_H
#define QCS_SINGLE_H

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>

/* ========================================================================= */
/* API FUNCTION DECLARATIONS AND STRUCTURES (from internal.h and qcs.h)      */
/* ========================================================================= */


/* COMPLEX NUMBERS */
struct t_complex {
  double number_real;
  double number_imaginary;
};

struct t_complex c_add(struct t_complex a, struct t_complex b);
struct t_complex c_sub(struct t_complex a, struct t_complex b);
struct t_complex c_mul(struct t_complex a, struct t_complex b);
struct t_complex c_conj(struct t_complex a);
struct t_complex c_zero(void);
struct t_complex c_one(void);
struct t_complex c_from_real(double real);
double c_norm_sq(struct t_complex a);
double c_magnitude(struct t_complex a);

/* QUANTUM STATE VECTOR */
struct t_q_state {
  int qubits_num;
  long size;
  struct t_complex *vector;
  struct t_complex *scratch_vector;
};

struct t_q_state *q_state_init(int qubits_num);
void q_state_free(struct t_q_state *state);
void q_state_set_basis(struct t_q_state *state, int index_basis);
void q_state_print(const struct t_q_state *state, int solution_index);

/* QUANTUM MATRIX */
struct t_q_matrix {
  int rows;
  int cols;
  struct t_complex *data;
};

struct t_q_matrix *q_matrix_init(int rows, int cols);
void q_matrix_free(struct t_q_matrix *mat);
void q_gate_apply(struct t_q_state *state, const struct t_q_matrix *gate);
void q_matrix_print(const struct t_q_matrix *mat);

/* QUANTUM GATES */
struct t_q_matrix *q_gate_I(void);
struct t_q_matrix *q_gate_X(void);
struct t_q_matrix *q_gate_H(void);
struct t_q_matrix *q_gate_CNOT(void);
struct t_q_matrix *q_gate_oracle(int num_qubits, int solution_index);
struct t_q_matrix *q_gate_U0(int num_qubits);
struct t_q_matrix *q_gate_diffusion(int num_qubits);
void q_apply_diffusion(struct t_q_state *state);
void q_apply_phase_flip(struct t_q_state *state, int target_index);
void q_apply_1q_gate(struct t_q_state *state, const struct t_q_matrix *gate,
                     int target_qubit);
void q_apply_2q_gate(struct t_q_state *state, const struct t_q_matrix *gate,
                     int control_qubit, int target_qubit);

/* QUANTUM UTILS */
void q_state_normalize(struct t_q_state *state);
int q_grover_iterations(int num_qubits);


/* Quantum Circuit Builder */
typedef struct t_q_circuit t_q_circuit;

/* Circuit Creation */
t_q_circuit *qc_create(int num_qubits);
void qc_destroy(t_q_circuit *circuit);

/* Basic Gates */
void qc_h(t_q_circuit *circuit, int qubit);
void qc_x(t_q_circuit *circuit, int qubit);
void qc_y(t_q_circuit *circuit, int qubit);
void qc_z(t_q_circuit *circuit, int qubit);
void qc_cnot(t_q_circuit *circuit, int control, int target);

/* Advanced Gates */
void qc_phase(t_q_circuit *circuit, int qubit, double angle);
void qc_rx(t_q_circuit *circuit, int qubit, double angle);
void qc_ry(t_q_circuit *circuit, int qubit, double angle);
void qc_rz(t_q_circuit *circuit, int qubit, double angle);

/* Circuit Operations */
void qc_barrier(t_q_circuit *circuit);
void qc_reset(t_q_circuit *circuit, int qubit);

/* Measurement */
int qc_measure(t_q_circuit *circuit, int qubit);
void qc_measure_all(t_q_circuit *circuit, int *results);

/* Circuit Execution */
void qc_run(t_q_circuit *circuit);
void qc_run_shots(t_q_circuit *circuit, int shots, int *results);

/* State Access */
double qc_get_probability(t_q_circuit *circuit, int state);
void qc_print_state(t_q_circuit *circuit);
void qc_print_circuit(t_q_circuit *circuit);

/* Built-in Algorithms */
void qc_grover_search(t_q_circuit *circuit, int solution_state, int iterations);
void qc_quantum_fourier_transform(t_q_circuit *circuit);
void qc_bernstein_vazirani(t_q_circuit *circuit, int hidden_string);

/* Utility Functions */
int qc_get_num_qubits(t_q_circuit *circuit);
int qc_get_num_gates(t_q_circuit *circuit);
void qc_optimize(t_q_circuit *circuit);



/* ========================================================================= */
/* IMPLEMENTATION (Define QCS_IMPLEMENTATION in ONE C source file to include */
/* definitions)                                                              */
/* ========================================================================= */
#ifdef QCS_IMPLEMENTATION


/* ------------------------------------------------------------------------- */
/* complex.c implementation                                         */
/* ------------------------------------------------------------------------- */

struct t_complex c_add(struct t_complex a, struct t_complex b) {
  struct t_complex result;

  result.number_real = a.number_real + b.number_real;
  result.number_imaginary = a.number_imaginary + b.number_imaginary;

  return result;
}

struct t_complex c_sub(struct t_complex a, struct t_complex b) {
  struct t_complex result;

  result.number_real = a.number_real - b.number_real;
  result.number_imaginary = a.number_imaginary - b.number_imaginary;

  return result;
}

struct t_complex c_mul(struct t_complex a, struct t_complex b) {
  struct t_complex result;

  result.number_real = (a.number_real * b.number_real) -
                       (a.number_imaginary * b.number_imaginary);

  result.number_imaginary = (a.number_real * b.number_imaginary) +
                            (a.number_imaginary * b.number_real);

  return result;
}

struct t_complex c_conj(struct t_complex a) {
  struct t_complex result;

  result.number_real = a.number_real;
  result.number_imaginary = -a.number_imaginary;
  ;

  return result;
}

struct t_complex c_zero(void) {
  struct t_complex zero = {0.0, 0.0};

  return zero;
}

struct t_complex c_one(void) {
  struct t_complex one = {1.0, 0.0};

  return one;
}

struct t_complex c_from_real(double real) {
  struct t_complex result;

  result.number_real = real;
  result.number_imaginary = 0.0;

  return result;
}
double c_norm_sq(struct t_complex a) {

  return (a.number_real * a.number_real) +
         (a.number_imaginary * a.number_imaginary);
}

double c_magnitude(struct t_complex a) {
  double norm_sq = c_norm_sq(a);

  return sqrt(norm_sq);
}
/* ------------------------------------------------------------------------- */
/* q_utils.c implementation                                         */
/* ------------------------------------------------------------------------- */

void q_state_normalize(struct t_q_state *state) {
  double total_norm_sq = 0.0;
  double inv_norm;
  long i;

  if (state == NULL || state->vector == NULL) {
    fprintf(stderr, "Error: Cannot normalize a NULL state.\n");
    return;
  }

  for (i = 0; i < state->size; i++) {
    total_norm_sq += c_norm_sq(state->vector[i]);
  }

  if (total_norm_sq == 1.0) {
    return;
  }
  if (total_norm_sq < 1e-12) {
    fprintf(stderr, "Warning: State vector has near-zero norm (uninitialized "
                    "or collapsed).\n");
    return;
  }

  inv_norm = 1.0 / sqrt(total_norm_sq);

  for (i = 0; i < state->size; i++) {
    state->vector[i].number_real *= inv_norm;
    state->vector[i].number_imaginary *= inv_norm;
  }
}

int q_grover_iterations(int num_qubits) {
  double const m_pi = (3.14159265358979323846);
  double N = (double)(1 << num_qubits);
  double R;

  R = (m_pi / 4.0) * sqrt(N);

  return (int)floor(R);
}
/* ------------------------------------------------------------------------- */
/* q_matrix.c implementation                                         */
/* ------------------------------------------------------------------------- */

struct t_q_matrix *q_matrix_init(int rows, int cols) {
  struct t_q_matrix *mat;
  int size = rows * cols;

  if (rows <= 0 || cols <= 0) {
    fprintf(stderr, "Error: Matrix dimensions must be postives\n");
    return NULL;
  }

  mat = (struct t_q_matrix *)malloc(sizeof(struct t_q_matrix));
  if (mat == NULL) {
    fprintf(stderr, "Error: Could not allocate t_q_matrix structure\n");
    return NULL;
  }

  mat->data = (struct t_complex *)calloc(size, sizeof(struct t_complex));
  if (mat->data == NULL) {
    fprintf(stderr, "Error: Could not allocate matrix data\n");
    return NULL;
  }

  mat->rows = rows;
  mat->cols = cols;

  return mat;
}

void q_matrix_free(struct t_q_matrix *mat) {
  if (mat) {
    if (mat->data) {
      free(mat->data);
    }
    free(mat);
  }
}

#define BLOCK_SIZE 50

void q_gate_apply(struct t_q_state *state, const struct t_q_matrix *gate) {
  struct t_complex *new_vector = state->scratch_vector;
  struct t_complex *vector = state->vector;
  struct t_complex *temp;

  long N = state->size;
  long i, j;
  long ii, jj;
  long N_block = 0;

  if (gate->cols != N || gate->rows != N) {
    fprintf(stderr, "Error: Gate dimensions (%dx%d) mismatch size (%ld)\n",
            gate->rows, gate->cols, N);
    return;
  }

  for (i = 0; i < N; i++) {
    new_vector[i] = c_zero();
  }

  for (ii = 0; ii < N; ii += BLOCK_SIZE) {
    N_block = ((ii + BLOCK_SIZE) < N) ? BLOCK_SIZE : (N - ii);
    for (jj = 0; jj < N; jj += BLOCK_SIZE) {
      for (i = ii; i < ii + N_block; i++) {
        for (j = jj; j < jj + BLOCK_SIZE; j++) {
          if (j < N) {
            new_vector[i] =
                c_add(new_vector[i], c_mul(gate->data[i * N + j], vector[j]));
          }
        }
      }
    }
  }

  temp = state->vector;
  state->vector = new_vector;
  state->scratch_vector = temp;
}
/* ------------------------------------------------------------------------- */
/* q_state.c implementation                                         */
/* ------------------------------------------------------------------------- */

struct t_q_state *q_state_init(int num_qubits) {
  struct t_q_state *state;
  long size;

  if (num_qubits <= 0) {
    fprintf(stderr, "Error: Number of qubits must be positive.\n");
    return NULL;
  }

  size = 1L << num_qubits;

  state = (struct t_q_state *)malloc(sizeof(struct t_q_state));
  if (state == NULL) {
    return NULL;
  }

  state->vector = (struct t_complex *)calloc(size, sizeof(struct t_complex));
  if (state->vector == NULL) {
    /* Cleanup main struct on failure */
    free(state);
    return NULL;
  }

  state->scratch_vector =
      (struct t_complex *)calloc(size, sizeof(struct t_complex));
  if (state->scratch_vector == NULL) {
    fprintf(stderr, "Error: Could not allocate scratch vector.\n");
    free(state->vector);
    free(state);
    return NULL;
  }

  state->qubits_num = num_qubits;
  state->size = size;

  return state;
}

void q_state_free(struct t_q_state *state) {
  if (state) {
    if (state->vector) {
      free(state->vector);
    }
    if (state->scratch_vector) {
      free(state->scratch_vector);
    }
    free(state);
  }
}

void q_state_set_basis(struct t_q_state *state, int index_basis) {
  long i;

  if (state == NULL || index_basis < 0 || index_basis >= state->size) {
    fprintf(stderr, "Error: Invalid state or basis index\n");
    return;
  }

  for (i = 0; i < state->size; i++) {
    state->vector[i] = c_zero();
  }

  state->vector[index_basis] = c_one();
}

void q_state_print(const struct t_q_state *state, int solution_index) {
  long i;
  int max_print = state->size > 8 ? 4 : state->size;
  int show_solution = 0;

  printf("--- Quantum State (%d Qubits) ---\n", state->qubits_num);

  for (i = 0; i < max_print; i++) {
    if (i == solution_index)
      show_solution = 1;
  }

  for (i = 0; i < max_print; i++) {
    printf("|%ld>: %f + i%f%s\n", i, state->vector[i].number_real,
           state->vector[i].number_imaginary,
           i == solution_index ? " <-- SOLUTION" : "");
  }

  if (!show_solution && solution_index >= 0 && solution_index < state->size) {
    printf("...\n");
    printf("|%d>: %f + i%f <-- SOLUTION\n", solution_index,
           state->vector[solution_index].number_real,
           state->vector[solution_index].number_imaginary);
    printf("...\n");
  } else if (state->size > 8) {
    printf("...\n");
  }

  if (state->size > 8) {
    printf("|%ld>: %f + i%f\n", state->size - 1,
           state->vector[state->size - 1].number_real,
           state->vector[state->size - 1].number_imaginary);
  }
  printf("----------------------------------\n");
}
/* ------------------------------------------------------------------------- */
/* q_gates.c implementation                                         */
/* ------------------------------------------------------------------------- */

struct t_q_matrix *q_gate_I(void) {
  struct t_q_matrix *i = q_matrix_init(2, 2);

  if (!i) {
    return NULL;
  }

  i->data[0] = c_one();
  i->data[3] = c_one();

  return i;
}

struct t_q_matrix *q_gate_X(void) {
  struct t_q_matrix *X = q_matrix_init(2, 2);

  if (!X) {
    return NULL;
  }

  X->data[0] = c_one();
  X->data[2] = c_one();

  return X;
}

struct t_q_matrix *q_gate_H(void) {
  double root2_inv = 1.0 / sqrt(2.0);
  struct t_complex factor = c_from_real(root2_inv);
  struct t_complex minus_one = c_from_real(-1.0);

  struct t_q_matrix *H = q_matrix_init(2, 2);

  if (!H) {
    return NULL;
  }

  H->data[0] = factor;
  H->data[1] = factor;
  H->data[2] = factor;
  H->data[3] = c_mul(factor, minus_one);

  return H;
}

struct t_q_matrix *q_gate_CNOT(void) {
  struct t_q_matrix *CNOT = q_matrix_init(4, 4);
  if (!CNOT)
    return NULL;

  CNOT->data[0] = c_one();
  CNOT->data[5] = c_one();

  CNOT->data[10] = c_one();
  CNOT->data[15] = c_one();

  return CNOT;
}

struct t_q_matrix *q_gate_oracle(int num_qubits, int solution_index) {
  int size = 1 << num_qubits;
  struct t_q_matrix *oracle;
  long i;

  if (solution_index < 0 || solution_index >= size) {
    fprintf(stderr, "Error: Invalid Oracle solution index.\n");
    return NULL;
  }

  oracle = q_matrix_init(size, size);
  if (!oracle)
    return NULL;

  for (i = 0; i < size; i++) {
    oracle->data[i * size + i] = c_one();
  }

  oracle->data[solution_index * size + solution_index] = c_from_real(-1.0);

  return oracle;
}

struct t_q_matrix *q_gate_U0(int num_qubits) {
  return q_gate_oracle(num_qubits, 0);
}

void old_q_apply_phase_flip(struct t_q_state *state, int target_index) {
  if (target_index >= 0 && target_index < state->size) {
    state->vector[target_index].number_real *= -1.0;
    state->vector[target_index].number_imaginary *= -1.0;
  } else {
    fprintf(stderr, "Error: Invalid target index for phase flip.\n");
  }
}

struct t_q_matrix *q_gate_diffusion(int num_qubits) {
  int size = 1 << num_qubits;
  struct t_q_matrix *diffusion;
  long i, j;
  double factor = 2.0 / size;

  diffusion = q_matrix_init(size, size);
  if (!diffusion)
    return NULL;

  for (i = 0; i < size; i++) {
    for (j = 0; j < size; j++) {
      if (i == j) {
        diffusion->data[i * size + j] = c_from_real(factor - 1.0);
      } else {
        diffusion->data[i * size + j] = c_from_real(factor);
      }
    }
  }

  return diffusion;
}

void q_apply_diffusion(struct t_q_state *state) {
  struct t_complex *vector = state->vector;
  struct t_complex *scratch = state->scratch_vector;
  long size = state->size;
  long i;

  struct t_complex mean = c_zero();
  for (i = 0; i < size; i++) {
    mean = c_add(mean, vector[i]);
  }
  mean.number_real /= size;
  mean.number_imaginary /= size;

  for (i = 0; i < size; i++) {
    struct t_complex two_mean;
    two_mean.number_real = 2.0 * mean.number_real;
    two_mean.number_imaginary = 2.0 * mean.number_imaginary;

    scratch[i].number_real = two_mean.number_real - vector[i].number_real;
    scratch[i].number_imaginary =
        two_mean.number_imaginary - vector[i].number_imaginary;
  }

  struct t_complex *temp = state->vector;
  state->vector = scratch;
  state->scratch_vector = temp;
}

void q_apply_phase_flip(struct t_q_state *state, int index) {
  if (state == NULL || index < 0 || index >= state->size) {
    fprintf(stderr, "Error: Invalid state or index for phase flip.\n");
    return;
  }

  state->vector[index] = c_mul(state->vector[index], c_from_real(-1.0));
}

void q_apply_1q_gate(struct t_q_state *state, const struct t_q_matrix *gate,
                     int target_qubit) {
  struct t_complex *vector = state->vector;
  struct t_complex *new_vector = state->scratch_vector;
  long i;
  long size = state->size;
  long step = 1L << target_qubit;
  long block_size = 1L << (target_qubit + 1);

  if (state == NULL || gate == NULL || target_qubit < 0 ||
      target_qubit >= state->qubits_num) {
    fprintf(stderr, "Error: Invalid arguments for 1-qubit gate application.\n");
    return;
  }

  for (i = 0; i < size; i += block_size) {
    long j;
    for (j = i; j < i + step; j++) {
      long index0 = j;
      long index1 = j + step;

      struct t_complex v0 = vector[index0];
      struct t_complex v1 = vector[index1];

      new_vector[index0] =
          c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
      new_vector[index1] =
          c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
    }
  }

  struct t_complex *temp = state->vector;
  state->vector = new_vector;
  state->scratch_vector = temp;
}

void q_apply_2q_gate(struct t_q_state *state, const struct t_q_matrix *gate,
                     int control_qubit, int target_qubit) {
  struct t_complex *vector = state->vector;
  struct t_complex *new_vector = state->scratch_vector;

  long i;
  long size = state->size;
  long c_bit = 1L << control_qubit;
  long t_bit = 1L << target_qubit;

  if (state == NULL || gate == NULL || control_qubit < 0 || target_qubit < 0 ||
      control_qubit >= state->qubits_num || target_qubit >= state->qubits_num) {
    fprintf(stderr, "Error: Invalid control/target qubit indices.\n");
    return;
  }

  for (i = 0; i < size; i++) {
    new_vector[i] = vector[i];
  }

  for (i = 0; i < size; i++) {
    if ((i & c_bit) == 0 && (i & t_bit) == 0) {
      long i00 = i;
      long i01 = i | t_bit;
      long i10 = i | c_bit;
      long i11 = i | t_bit | c_bit;

      struct t_complex amp_00 = vector[i00];
      struct t_complex amp_01 = vector[i01];
      struct t_complex amp_10 = vector[i10];
      struct t_complex amp_11 = vector[i11];

      new_vector[i00] = c_add(
          c_add(c_mul(gate->data[0], amp_00), c_mul(gate->data[1], amp_01)),
          c_add(c_mul(gate->data[2], amp_10), c_mul(gate->data[3], amp_11)));

      new_vector[i01] = c_add(
          c_add(c_mul(gate->data[4], amp_00), c_mul(gate->data[5], amp_01)),
          c_add(c_mul(gate->data[6], amp_10), c_mul(gate->data[7], amp_11)));

      new_vector[i10] = c_add(
          c_add(c_mul(gate->data[8], amp_00), c_mul(gate->data[9], amp_01)),
          c_add(c_mul(gate->data[10], amp_10), c_mul(gate->data[11], amp_11)));

      new_vector[i11] = c_add(
          c_add(c_mul(gate->data[12], amp_00), c_mul(gate->data[13], amp_01)),
          c_add(c_mul(gate->data[14], amp_10), c_mul(gate->data[15], amp_11)));
    }
  }

  state->vector = new_vector;
  state->scratch_vector = vector;
}
/* ------------------------------------------------------------------------- */
/* qsc.c implementation                                         */
/* ------------------------------------------------------------------------- */

struct t_q_circuit {
  int num_qubits;
  int num_gates;
  struct t_q_state *state;
  char **gate_history;
  int *target_qubits;
  int *control_qubits;
  double *parameters;
  int history_size;
  int history_capacity;
};

t_q_circuit *qc_create(int num_qubits) {
  t_q_circuit *circuit = (t_q_circuit *)malloc(sizeof(t_q_circuit));
  if (!circuit)
    return NULL;

  circuit->num_qubits = num_qubits;
  circuit->num_gates = 0;
  circuit->state = q_state_init(num_qubits);
  circuit->history_size = 0;
  circuit->history_capacity = 100;

  q_state_set_basis(circuit->state, 0);

  circuit->gate_history =
      (char **)malloc(circuit->history_capacity * sizeof(char *));
  circuit->target_qubits =
      (int *)malloc(circuit->history_capacity * sizeof(int));
  circuit->control_qubits =
      (int *)malloc(circuit->history_capacity * sizeof(int));
  circuit->parameters =
      (double *)malloc(circuit->history_capacity * sizeof(double));

  return circuit;
}

void qc_destroy(t_q_circuit *circuit) {
  int i;

  if (circuit) {
    if (circuit->state)
      q_state_free(circuit->state);
    if (circuit->gate_history) {
      for (i = 0; i < circuit->history_size; i++) {
        free(circuit->gate_history[i]);
      }
      free(circuit->gate_history);
    }
    if (circuit->target_qubits)
      free(circuit->target_qubits);
    if (circuit->control_qubits)
      free(circuit->control_qubits);
    if (circuit->parameters)
      free(circuit->parameters);
    free(circuit);
  }
}

static char *qc_strdup(const char *str) {
  if (str == NULL)
    return NULL;

  size_t len = strlen(str) + 1;
  char *copy = (char *)malloc(len);
  if (copy) {
    memcpy(copy, str, len);
  }
  return copy;
}

void qc_add_gate(t_q_circuit *circuit, const char *gate_name, int target,
                 int control, double param) {
  if (circuit->history_size >= circuit->history_capacity) {
    circuit->history_capacity *= 2;
    circuit->gate_history = (char **)realloc(
        circuit->gate_history, circuit->history_capacity * sizeof(char *));
    circuit->target_qubits = (int *)realloc(
        circuit->target_qubits, circuit->history_capacity * sizeof(int));
    circuit->control_qubits = (int *)realloc(
        circuit->control_qubits, circuit->history_capacity * sizeof(int));
    circuit->parameters = (double *)realloc(
        circuit->parameters, circuit->history_capacity * sizeof(double));
  }

  circuit->gate_history[circuit->history_size] = qc_strdup(gate_name);
  circuit->target_qubits[circuit->history_size] = target;
  circuit->control_qubits[circuit->history_size] = control;
  circuit->parameters[circuit->history_size] = param;
  circuit->history_size++;
  circuit->num_gates++;
}

void qc_h(t_q_circuit *circuit, int qubit) {
  struct t_q_matrix *H = q_gate_H();
  q_apply_1q_gate(circuit->state, H, qubit);
  q_matrix_free(H);
  qc_add_gate(circuit, "H", qubit, -1, 0.0);
}

void qc_x(t_q_circuit *circuit, int qubit) {
  struct t_q_matrix *X = q_gate_X();
  q_apply_1q_gate(circuit->state, X, qubit);
  q_matrix_free(X);
  qc_add_gate(circuit, "X", qubit, -1, 0.0);
}

void qc_cnot(t_q_circuit *circuit, int control, int target) {
  struct t_q_matrix *CNOT = q_gate_CNOT();
  q_apply_2q_gate(circuit->state, CNOT, control, target);
  q_matrix_free(CNOT);
  qc_add_gate(circuit, "CNOT", target, control, 0.0);
}

int qc_measure(t_q_circuit *circuit, int qubit) {
  if (circuit == NULL || circuit->state == NULL || qubit < 0 ||
      qubit >= circuit->num_qubits) {
    return 0;
  }

  long state_size = circuit->state->size;
  double prob_0 = 0.0;
  long i;

  for (i = 0; i < state_size; i++) {
    if ((i & (1L << qubit)) == 0) {
      double amp_real = circuit->state->vector[i].number_real;
      double amp_imag = circuit->state->vector[i].number_imaginary;
      prob_0 += (amp_real * amp_real) + (amp_imag * amp_imag);
    }
  }

  double random_val = rand() / (double)RAND_MAX;

  if (random_val <= prob_0) {
    for (i = 0; i < state_size; i++) {
      if ((i & (1L << qubit)) != 0) {
        circuit->state->vector[i].number_real = 0.0;
        circuit->state->vector[i].number_imaginary = 0.0;
      }
    }
    q_state_normalize(circuit->state);
    return 0;

  } else {
    for (i = 0; i < state_size; i++) {
      if ((i & (1L << qubit)) == 0) {
        circuit->state->vector[i].number_real = 0.0;
        circuit->state->vector[i].number_imaginary = 0.0;
      }
    }

    q_state_normalize(circuit->state);
    return 1;
  }
}

void qc_measure_all(t_q_circuit *circuit, int *results) {
  if (circuit == NULL || results == NULL)
    return;

  int i;

  for (i = 0; i < circuit->num_qubits; i++) {
    results[i] = qc_measure(circuit, i);
  }

  qc_add_gate(circuit, "MEASURE", -1, -1, 0.0);
}

void qc_print_circuit(t_q_circuit *circuit) {
  int q;
  int g;

  printf("\n╔══════════════════════════════════════════╗\n");
  printf("║              QUANTUM CIRCUIT             ║\n");
  printf("╚══════════════════════════════════════════╝\n");
  printf("Qubits: %d | Gates: %d\n\n", circuit->num_qubits, circuit->num_gates);

  int has_measurement = 0;

  for (g = 0; g < circuit->history_size; g++) {
    if (strcmp(circuit->gate_history[g], "MEASURE") == 0) {
      has_measurement = 1;
      break;
    }
  }

  for (q = 0; q < circuit->num_qubits; q++) {
    printf("q%-2d ", q);

    for (g = 0; g < circuit->history_size; g++) {
      const char *gate = circuit->gate_history[g];
      int target = circuit->target_qubits[g];
      int control = circuit->control_qubits[g];

      if (strcmp(gate, "H") == 0 && target == q) {
        printf("─H─");
      } else if (strcmp(gate, "X") == 0 && target == q) {
        printf("─X─");
      } else if (strcmp(gate, "CNOT") == 0) {
        if (control == q)
          printf("─∙─");
        else if (target == q)
          printf("─⊕─");
        else
          printf("───");
      } else {
        printf("───");
      }

      if (g < circuit->history_size - 1)
        printf("─");
    }
    if (!has_measurement) {
      printf("─M─");
    }
    printf("─┐\n");
  }

  printf("\nGATE SEQUENCE: ");
  for (g = 0; g < circuit->history_size; g++) {
    const char *gate = circuit->gate_history[g];
    int target = circuit->target_qubits[g];
    int control = circuit->control_qubits[g];

    if (strcmp(gate, "CNOT") == 0) {
      printf("CNOT(%d,%d) ", control, target);
    } else if (strcmp(gate, "MEASURE") == 0) {
      printf("MEASURE ");
    } else {
      printf("%s(%d) ", gate, target);
    }
  }
  printf("\n\n");
}

void qc_print_state(t_q_circuit *circuit) { q_state_print(circuit->state, -1); }

double qc_get_probability(t_q_circuit *circuit, int state) {
  if (state < 0 || state >= circuit->state->size)
    return 0.0;
  return c_norm_sq(circuit->state->vector[state]);
}

void qc_grover_search(t_q_circuit *circuit, int solution_state,
                      int iterations) {
  int q;
  int i;

  printf("Running Grover's Search for |%d⟩ (%d iterations)\n", solution_state,
         iterations);

  for (q = 0; q < circuit->num_qubits; q++) {
    qc_h(circuit, q);
  }

  for (i = 0; i < iterations; i++) {
    q_apply_phase_flip(circuit->state, solution_state);
    qc_add_gate(circuit, "ORACLE", solution_state, -1, 0.0);
    q_apply_diffusion(circuit->state);
    qc_add_gate(circuit, "DIFFUSION", -1, -1, 0.0);
  }
}

int qc_get_num_qubits(t_q_circuit *circuit) { return circuit->num_qubits; }
int qc_get_num_gates(t_q_circuit *circuit) { return circuit->num_gates; }

void qc_y(t_q_circuit *circuit, int qubit);
void qc_z(t_q_circuit *circuit, int qubit);
void qc_phase(t_q_circuit *circuit, int qubit, double angle);
void qc_barrier(t_q_circuit *circuit);
void qc_reset(t_q_circuit *circuit, int qubit);
void qc_run(t_q_circuit *circuit);
void qc_run_shots(t_q_circuit *circuit, int shots, int *results);
void qc_quantum_fourier_transform(t_q_circuit *circuit);
void qc_bernstein_vazirani(t_q_circuit *circuit, int hidden_string);
void qc_optimize(t_q_circuit *circuit);

#endif /* QCS_IMPLEMENTATION */
#endif /* QCS_SINGLE_H */
