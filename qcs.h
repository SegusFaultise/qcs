
/*
 * Quantum Computing Simulator (QCS) - Single Header Library
 *
 * File: qcs.h
 * Generated: 2025-10-06
 * Author: SegusFaultise / Zakk Wilson-Christian
 * Auto-Generated by bundle.py
 * 
 * PARALLELIZATION MODE SELECTION:
 * 
 * QCS is sequential by default for maximum compatibility and simplicity.
 * 
 * To enable parallelization, define one of the following BEFORE including qcs.h:
 * 
 * #define QCS_MULTI_THREAD    - Use pthread threads for parallelization
 * #define QCS_CPU_OPENMP      - Use OpenMP parallel loops
 * #define QCS_GPU_OPENCL      - Use OpenCL GPU acceleration
 * #define QCS_SIMD_ONLY       - Use SIMD vectorization only
 * 
 * Example usage:
 * #define QCS_GPU_OPENCL
 * #define QCS_IMPLEMENTATION
 * #include "qcs.h"
 * 
 * If no parallelization mode is defined, QCS runs in pure sequential mode
 * with no parallelization overhead.
 */

/*
 * The MIT License (MIT)
 * * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


#ifndef QCS_H
#define QCS_H

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/time.h>
#include <time.h>

/* ========================================================================= */
/* API FUNCTION DECLARATIONS AND STRUCTURES (from internal.h and qcs.h)      */
/* ========================================================================= */


#include <pthread.h>

struct t_complex {
  double number_real;
  double number_imaginary;
};

struct t_complex c_add(struct t_complex a, struct t_complex b);
struct t_complex c_sub(struct t_complex a, struct t_complex b);
struct t_complex c_mul(struct t_complex a, struct t_complex b);
struct t_complex c_conj(struct t_complex a);
struct t_complex c_zero(void);
struct t_complex c_one(void);
struct t_complex c_from_real(double real);
double c_norm_sq(struct t_complex a);
double c_magnitude(struct t_complex a);

void c_add_simd(struct t_complex *result, const struct t_complex *a, 
                const struct t_complex *b, long count);
void c_mul_simd(struct t_complex *result, const struct t_complex *a, 
                const struct t_complex *b, long count);
void c_copy_simd(struct t_complex *dest, const struct t_complex *src, long count);
double c_norm_sq_sum_simd(const struct t_complex *a, long count);

void c_add_gpu(struct t_complex *result, const struct t_complex *a, 
                const struct t_complex *b, long count);
void c_mul_gpu(struct t_complex *result, const struct t_complex *a, 
                const struct t_complex *b, long count);
void c_copy_gpu(struct t_complex *dest, const struct t_complex *src, long count);
double c_norm_sq_sum_gpu(const struct t_complex *a, long count);

void c_add_gpu_real(struct t_complex *result, const struct t_complex *a, 
                    const struct t_complex *b, long count);
void c_mul_gpu_real(struct t_complex *result, const struct t_complex *a, 
                    const struct t_complex *b, long count);
void c_copy_gpu_real(struct t_complex *dest, const struct t_complex *src, long count);
double c_norm_sq_sum_gpu_real(const struct t_complex *a, long count);


struct t_q_state {
  int qubits_num;
  long size;
  struct t_complex *vector;
  struct t_complex *scratch_vector;
};

struct t_q_state *q_state_init(int qubits_num);
void q_state_free(struct t_q_state *state);
void q_state_set_basis(struct t_q_state *state, int index_basis);
void q_state_print(const struct t_q_state *state, int solution_index);

struct t_q_matrix {
  int rows;
  int cols;
  struct t_complex *data;
};

struct t_q_matrix *q_matrix_init(int rows, int cols);
void q_matrix_free(struct t_q_matrix *mat);
void q_gate_apply(struct t_q_state *state, const struct t_q_matrix *gate);
void q_matrix_print(const struct t_q_matrix *mat);

struct t_q_matrix *q_gate_I(void);
struct t_q_matrix *q_gate_X(void);
struct t_q_matrix *q_gate_H(void);
struct t_q_matrix *q_gate_CNOT(void);
struct t_q_matrix *q_gate_CP(double angle);
struct t_q_matrix *q_gate_P(double angle);
struct t_q_matrix *q_gate_Z(void);
struct t_q_matrix *q_gate_Y(void);
struct t_q_matrix *q_gate_RX(double angle);
struct t_q_matrix *q_gate_RY(double angle);
struct t_q_matrix *q_gate_RZ(double angle);

void q_apply_diffusion(struct t_q_state *state);
void q_apply_phase_flip(struct t_q_state *state, int target_index);
void q_apply_1q_gate(struct t_q_state *state, const struct t_q_matrix *gate,
                     int target_qubit);
void q_apply_2q_gate(struct t_q_state *state, const struct t_q_matrix *gate,
                     int control_qubit, int target_qubit);

void q_state_normalize(struct t_q_state *state);
int q_grover_iterations(int num_qubits);

#include <pthread.h>

struct t_task {
  void (*function)(void *arg);
  void *argument;
};

typedef struct {
  pthread_t *threads;
  struct t_task *task_queue;
  int num_threads;
  int queue_size;
  int head;
  int tail;
  int task_count;
  int active_tasks;
  int shutdown;

  pthread_mutex_t lock;
  pthread_cond_t notify;
  pthread_cond_t all_tasks_done;
} thread_pool_t;

thread_pool_t *thread_pool_create(int num_threads, int queue_size);
int thread_pool_add_task(thread_pool_t *pool, void (*function)(void *),
                         void *arg);
void thread_pool_wait(thread_pool_t *pool);
int thread_pool_destroy(thread_pool_t *pool);
void get_thread_work_range(long total_size, int num_threads, int thread_id,
                           long *start, long *end);

/* PTHREADS THREAD ARGS*/
#define CACHE_LINE_SIZE 64

struct t_thread_args {
  long start;
  long end;

  int target_qubit;
  int control_qubit;

  struct t_complex mean;
  struct t_q_state *state;
  const struct t_q_matrix *gate;

  union {
    struct {
      double partial_real_sum;
      double partial_imag_sum;
    } sums;
    char pad[CACHE_LINE_SIZE];
  } reduction_result;

} __attribute__((aligned(CACHE_LINE_SIZE)));


/* ======================================================================== */
/* QCS PARALLELIZATION MODE SELECTION */
/* ======================================================================== */
/* 
 * QCS is sequential by default for maximum compatibility and simplicity.
 * 
 * To enable parallelization, define one of the following BEFORE including qcs.h:
 * 
 * #define QCS_MULTI_THREAD    - Use pthread threads for parallelization
 * #define QCS_CPU_OPENMP      - Use OpenMP parallel loops
 * #define QCS_GPU_OPENCL      - Use OpenCL GPU acceleration
 * #define QCS_SIMD_ONLY       - Use SIMD vectorization only
 * 
 * Example usage:
 *  * 
 * 
 * If no parallelization mode is defined, QCS runs in pure sequential mode
 * with no parallelization overhead.
 */

/* ======================================================================== */
/* QUANTUM CIRCUIT BUILDER */
/* ======================================================================== */
typedef struct t_q_circuit t_q_circuit;

/* Circuit Creation */
t_q_circuit *qc_create(int num_qubits);
void qc_destroy(t_q_circuit *circuit);

/* Basic Gates */
void qc_h(t_q_circuit *circuit, int qubit);
void qc_x(t_q_circuit *circuit, int qubit);
void qc_y(t_q_circuit *circuit, int qubit);
void qc_z(t_q_circuit *circuit, int qubit);
void qc_cnot(t_q_circuit *circuit, int control, int target);

/* Advanced Gates */
void qc_phase(t_q_circuit *circuit, int qubit, double angle);
void qc_rx(t_q_circuit *circuit, int qubit, double angle);
void qc_ry(t_q_circuit *circuit, int qubit, double angle);
void qc_rz(t_q_circuit *circuit, int qubit, double angle);

/* Circuit Operations */
void qc_barrier(t_q_circuit *circuit);
void qc_reset(t_q_circuit *circuit, int qubit);

/* Measurement */
int qc_measure(t_q_circuit *circuit, int qubit);
void qc_measure_all(t_q_circuit *circuit, int *results);

/* Circuit Execution */
void qc_run(t_q_circuit *circuit);
void qc_run_shots(t_q_circuit *circuit, int shots, int *results);

/* State Access */
int qc_find_most_likely_state(t_q_circuit *circuit);
double qc_get_probability(t_q_circuit *circuit, int state);
void qc_print_state(t_q_circuit *circuit, int solution_index);
void qc_print_circuit(t_q_circuit *circuit);

/* Built-in Algorithms */
void qc_grover_search(t_q_circuit *circuit, int solution_state);
void qc_quantum_fourier_transform(t_q_circuit *circuit);
void qc_bernstein_vazirani(t_q_circuit *circuit, int hidden_string);
void qc_ghz_state(t_q_circuit *circuit);

/* Utility Functions */
int qc_get_num_qubits(t_q_circuit *circuit);
int qc_get_num_gates(t_q_circuit *circuit);
void qc_optimize(t_q_circuit *circuit);



/* ========================================================================= */
/* IMPLEMENTATION (Define QCS_IMPLEMENTATION in ONE C source file to include */
/* definitions)                                                              */
/* ========================================================================= */
#ifdef QCS_IMPLEMENTATION

/* Forward declarations for worker functions */
#ifdef QCS_MULTI_THREAD
static void q_apply_1q_gate_worker(void *arg);
static void q_apply_2q_gate_worker(void *arg);
#endif


/* ------------------------------------------------------------------------- */
/* complex.c implementation                                         */
/* ------------------------------------------------------------------------- */

#ifdef __AVX2__
#include <immintrin.h>
#define SIMD_AVAILABLE 1
#else
#define SIMD_AVAILABLE 0
#endif

#ifdef _OPENMP
#define GPU_AVAILABLE 1
#else
#define GPU_AVAILABLE 0
#endif

/**
 * Add two complex numbers
 * @param a First complex number
 * @param b Second complex number
 * @return Sum of a and b
 */
struct t_complex c_add(struct t_complex a, struct t_complex b) {
  struct t_complex result;

  result.number_real = a.number_real + b.number_real;
  result.number_imaginary = a.number_imaginary + b.number_imaginary;

  return result;
}

struct t_complex c_sub(struct t_complex a, struct t_complex b) {
  struct t_complex result;

  result.number_real = a.number_real - b.number_real;
  result.number_imaginary = a.number_imaginary - b.number_imaginary;

  return result;
}

/**
 * Multiply two complex numbers
 * @param a First complex number
 * @param b Second complex number
 * @return Product of a and b
 */
struct t_complex c_mul(struct t_complex a, struct t_complex b) {
  struct t_complex result;

  result.number_real = (a.number_real * b.number_real) -
                       (a.number_imaginary * b.number_imaginary);

  result.number_imaginary = (a.number_real * b.number_imaginary) +
                            (a.number_imaginary * b.number_real);

  return result;
}

struct t_complex c_conj(struct t_complex a) {
  struct t_complex result;

  result.number_real = a.number_real;
  result.number_imaginary = -a.number_imaginary;
  ;

  return result;
}

struct t_complex c_zero(void) {
  struct t_complex zero = {0.0, 0.0};

  return zero;
}

struct t_complex c_one(void) {
  struct t_complex one = {1.0, 0.0};

  return one;
}

struct t_complex c_from_real(double real) {
  struct t_complex result;

  result.number_real = real;
  result.number_imaginary = 0.0;

  return result;
}
double c_norm_sq(struct t_complex a) {

  return (a.number_real * a.number_real) +
         (a.number_imaginary * a.number_imaginary);
}

double c_magnitude(struct t_complex a) {
  double norm_sq = c_norm_sq(a);

  return sqrt(norm_sq);
}

/* SIMD-optimized bulk operations */
#if SIMD_AVAILABLE

/* SIMD-optimized complex addition for arrays */
void c_add_simd(struct t_complex *result, const struct t_complex *a, 
                const struct t_complex *b, long count) {
  long i;
  
  /* Process 4 complex numbers at a time using AVX2 */
  for (i = 0; i < count - 3; i += 4) {
    /* Load 4 complex numbers (8 doubles) from array a */
    __m256d a_vec = _mm256_load_pd((double*)&a[i]);
    
    /* Load 4 complex numbers (8 doubles) from array b */
    __m256d b_vec = _mm256_load_pd((double*)&b[i]);
    
    /* Add them together */
    __m256d result_vec = _mm256_add_pd(a_vec, b_vec);
    
    /* Store the result */
    _mm256_store_pd((double*)&result[i], result_vec);
  }
  
  /* Handle remaining elements */
  for (; i < count; i++) {
    result[i] = c_add(a[i], b[i]);
  }
}

/* SIMD-optimized complex multiplication for arrays */
void c_mul_simd(struct t_complex *result, const struct t_complex *a, 
                const struct t_complex *b, long count) {
  long i;
  
  /* Process 2 complex numbers at a time using AVX2 */
  for (i = 0; i < count - 1; i += 2) {
    /* Load 2 complex numbers (4 doubles) from array a */
    __m256d a_vec = _mm256_load_pd((double*)&a[i]);
    
    /* Load 2 complex numbers (4 doubles) from array b */
    __m256d b_vec = _mm256_load_pd((double*)&b[i]);
    
    /* Extract real and imaginary parts */
    __m256d a_real = _mm256_unpacklo_pd(a_vec, a_vec);
    __m256d a_imag = _mm256_unpackhi_pd(a_vec, a_vec);
    __m256d b_real = _mm256_unpacklo_pd(b_vec, b_vec);
    __m256d b_imag = _mm256_unpackhi_pd(b_vec, b_vec);
    
    /* Complex multiplication: (a+bi)(c+di) = (ac-bd) + (ad+bc)i */
    __m256d real_part = _mm256_sub_pd(_mm256_mul_pd(a_real, b_real), 
                                      _mm256_mul_pd(a_imag, b_imag));
    __m256d imag_part = _mm256_add_pd(_mm256_mul_pd(a_real, b_imag), 
                                      _mm256_mul_pd(a_imag, b_real));
    
    /* Interleave real and imaginary parts */
    __m256d result_vec = _mm256_unpacklo_pd(real_part, imag_part);
    
    /* Store the result */
    _mm256_store_pd((double*)&result[i], result_vec);
  }
  
  /* Handle remaining elements */
  for (; i < count; i++) {
    result[i] = c_mul(a[i], b[i]);
  }
}

/* SIMD-optimized memory copy with alignment */
void c_copy_simd(struct t_complex *dest, const struct t_complex *src, long count) {
  long i;
  
  /* Process 4 complex numbers (8 doubles) at a time */
  for (i = 0; i < count - 3; i += 4) {
    __m256d src_vec = _mm256_load_pd((double*)&src[i]);
    _mm256_store_pd((double*)&dest[i], src_vec);
  }
  
  /* Handle remaining elements */
  for (; i < count; i++) {
    dest[i] = src[i];
  }
}

/* SIMD-optimized norm squared calculation */
double c_norm_sq_sum_simd(const struct t_complex *a, long count) {
  long i;
  double sum = 0.0;
  
  /* Process 4 complex numbers at a time */
  for (i = 0; i < count - 3; i += 4) {
    __m256d a_vec = _mm256_load_pd((double*)&a[i]);
    
    /* Square the values */
    __m256d squared = _mm256_mul_pd(a_vec, a_vec);
    
    /* Sum the squared values */
    __m256d sum_vec = _mm256_hadd_pd(squared, squared);
    sum += _mm256_cvtsd_f64(sum_vec) + _mm256_cvtsd_f64(_mm256_permute4x64_pd(sum_vec, 0x4E));
  }
  
  /* Handle remaining elements */
  for (; i < count; i++) {
    sum += c_norm_sq(a[i]);
  }
  
  return sum;
}

#else

/* Fallback implementations when SIMD is not available */
void c_add_simd(struct t_complex *result, const struct t_complex *a, 
                const struct t_complex *b, long count) {
  long i;
  for (i = 0; i < count; i++) {
    result[i] = c_add(a[i], b[i]);
  }
}

void c_mul_simd(struct t_complex *result, const struct t_complex *a, 
                const struct t_complex *b, long count) {
  long i;
  for (i = 0; i < count; i++) {
    result[i] = c_mul(a[i], b[i]);
  }
}

void c_copy_simd(struct t_complex *dest, const struct t_complex *src, long count) {
  long i;
  for (i = 0; i < count; i++) {
    dest[i] = src[i];
  }
}

double c_norm_sq_sum_simd(const struct t_complex *a, long count) {
  long i;
  double sum = 0.0;
  for (i = 0; i < count; i++) {
    sum += c_norm_sq(a[i]);
  }
  return sum;
}

#endif

/* GPU-accelerated bulk operations using OpenMP GPU offloading */
#if GPU_AVAILABLE

/* OpenMP-accelerated complex addition for arrays */
void c_add_gpu(struct t_complex *result, const struct t_complex *a, 
                const struct t_complex *b, long count) {
  long i;
  
  /* Use OpenMP parallel for large arrays */
  if (count > 100000) {  /* Only use OpenMP for large arrays */
    #pragma omp parallel for
    for (i = 0; i < count; i++) {
      result[i].number_real = a[i].number_real + b[i].number_real;
      result[i].number_imaginary = a[i].number_imaginary + b[i].number_imaginary;
    }
  } else {
    /* Fallback to SIMD for smaller arrays */
    c_add_simd(result, a, b, count);
  }
}

/* OpenMP-accelerated complex multiplication for arrays */
void c_mul_gpu(struct t_complex *result, const struct t_complex *a, 
                const struct t_complex *b, long count) {
  long i;
  
  /* Use OpenMP parallel for large arrays */
  if (count > 100000) {  /* Only use OpenMP for large arrays */
    #pragma omp parallel for
    for (i = 0; i < count; i++) {
      double real_part = a[i].number_real * b[i].number_real - 
                        a[i].number_imaginary * b[i].number_imaginary;
      double imag_part = a[i].number_real * b[i].number_imaginary + 
                        a[i].number_imaginary * b[i].number_real;
      result[i].number_real = real_part;
      result[i].number_imaginary = imag_part;
    }
  } else {
    /* Fallback to SIMD for smaller arrays */
    c_mul_simd(result, a, b, count);
  }
}

/* OpenMP-accelerated memory copy */
void c_copy_gpu(struct t_complex *dest, const struct t_complex *src, long count) {
  long i;
  
  /* Use OpenMP parallel for large arrays */
  if (count > 100000) {  /* Only use OpenMP for large arrays */
    #pragma omp parallel for
    for (i = 0; i < count; i++) {
      dest[i] = src[i];
    }
  } else {
    /* Fallback to SIMD for smaller arrays */
    c_copy_simd(dest, src, count);
  }
}

/* OpenMP-accelerated norm squared calculation */
double c_norm_sq_sum_gpu(const struct t_complex *a, long count) {
  double sum = 0.0;
  long i;
  
  /* Use OpenMP parallel for large arrays */
  if (count > 100000) {  /* Only use OpenMP for large arrays */
    #pragma omp parallel for reduction(+:sum)
    for (i = 0; i < count; i++) {
      sum += a[i].number_real * a[i].number_real + a[i].number_imaginary * a[i].number_imaginary;
    }
  } else {
    /* Fallback to SIMD for smaller arrays */
    sum = c_norm_sq_sum_simd(a, count);
  }
  
  return sum;
}

#else

/* Fallback implementations when GPU is not available */
void c_add_gpu(struct t_complex *result, const struct t_complex *a, 
                const struct t_complex *b, long count) {
  c_add_simd(result, a, b, count);
}

void c_mul_gpu(struct t_complex *result, const struct t_complex *a, 
                const struct t_complex *b, long count) {
  c_mul_simd(result, a, b, count);
}

void c_copy_gpu(struct t_complex *dest, const struct t_complex *src, long count) {
  c_copy_simd(dest, src, count);
}

double c_norm_sq_sum_gpu(const struct t_complex *a, long count) {
  return c_norm_sq_sum_simd(a, count);
}

#endif
/* ------------------------------------------------------------------------- */
/* q_utils.c implementation                                         */
/* ------------------------------------------------------------------------- */

#ifdef QCS_MULTI_THREAD
extern thread_pool_t *pool;
#endif

/**
 * Worker function for parallel normalization sum calculation
 * @param arg Thread arguments containing state and range
 */
static void normalize_sum_worker(void *arg) {
  struct t_thread_args *args = (struct t_thread_args *)arg;
  args->reduction_result.sums.partial_real_sum = 0.0;
  long i;
  for (i = args->start; i < args->end; i++) {
    args->reduction_result.sums.partial_real_sum +=
        c_norm_sq(args->state->vector[i]);
  }
}

/**
 * Worker function for parallel normalization division
 * @param arg Thread arguments containing state and range
 */
static void normalize_divide_worker(void *arg) {
  struct t_thread_args *args = (struct t_thread_args *)arg;
  double inv_norm = args->mean.number_real;
  long i;
  for (i = args->start; i < args->end; i++) {
    args->state->vector[i].number_real *= inv_norm;
    args->state->vector[i].number_imaginary *= inv_norm;
  }
  free(args);
}

/**
 * Normalize quantum state vector to unit length
 * @param state Quantum state to normalize
 */
void q_state_normalize(struct t_q_state *state) {
  if (state == NULL || state->vector == NULL)
    return;

#ifdef QCS_MULTI_THREAD
  int i;
  long size;
  struct t_thread_args **reduction_args_list;
  double total_norm_sq = 0.0;

  size = state->size;
  reduction_args_list =
      malloc(pool->num_threads * sizeof(struct t_thread_args *));
  if (!reduction_args_list)
    exit(EXIT_FAILURE);

  for (i = 0; i < pool->num_threads; i++) {
    long start, end;
    get_thread_work_range(size, pool->num_threads, i, &start, &end);

    reduction_args_list[i] = malloc(sizeof(struct t_thread_args));
    if (!reduction_args_list[i])
      exit(EXIT_FAILURE);

    reduction_args_list[i]->start = start;
    reduction_args_list[i]->end = end;
    reduction_args_list[i]->state = state;

    thread_pool_add_task(pool, normalize_sum_worker, reduction_args_list[i]);
  }
  thread_pool_wait(pool);

  for (i = 0; i < pool->num_threads; i++) {
    total_norm_sq +=
        reduction_args_list[i]->reduction_result.sums.partial_real_sum;
    free(reduction_args_list[i]);
  }
  free(reduction_args_list);

  if (total_norm_sq > 1e-12 && total_norm_sq != 1.0) {
    double inv_norm = 1.0 / sqrt(total_norm_sq);
    for (i = 0; i < pool->num_threads; i++) {
      long start, end;
      get_thread_work_range(size, pool->num_threads, i, &start, &end);

      struct t_thread_args *div_args = malloc(sizeof(struct t_thread_args));
      if (div_args == NULL) {
        exit(EXIT_FAILURE);
      }
      div_args->start = start;
      div_args->end = end;
      div_args->state = state;
      div_args->mean.number_real = inv_norm;

      thread_pool_add_task(pool, normalize_divide_worker, div_args);
    }
    thread_pool_wait(pool);
  }
#else
  long i;
  long size = state->size;
  double total_norm_sq = 0.0;

  for (i = 0; i < size; i++) {
    total_norm_sq += c_norm_sq(state->vector[i]);
  }

  if (total_norm_sq > 1e-12 && total_norm_sq != 1.0) {
    double inv_norm = 1.0 / sqrt(total_norm_sq);
    for (i = 0; i < size; i++) {
      state->vector[i].number_real *= inv_norm;
      state->vector[i].number_imaginary *= inv_norm;
    }
  }
#endif
}

/**
 * Calculate optimal number of Grover iterations
 * @param num_qubits Number of qubits in the system
 * @return Number of iterations needed
 */
int q_grover_iterations(int num_qubits) {
  double const m_pi = (3.14159265358979323846);
  double N = (double)(1 << num_qubits);
  double R;

  R = (m_pi / 4.0) * sqrt(N);

  return (int)floor(R);
}
/* ------------------------------------------------------------------------- */
/* q_matrix.c implementation                                         */
/* ------------------------------------------------------------------------- */

/**
 * Initialize a quantum matrix with specified dimensions
 * @param rows Number of rows
 * @param cols Number of columns
 * @return Pointer to allocated matrix or NULL on failure
 */
struct t_q_matrix *q_matrix_init(int rows, int cols) {
  struct t_q_matrix *mat;
  int size = rows * cols;

  if (rows <= 0 || cols <= 0) {
    fprintf(stderr, "Error: Matrix dimensions must be postives\n");
    return NULL;
  }

  mat = (struct t_q_matrix *)malloc(sizeof(struct t_q_matrix));
  if (mat == NULL) {
    fprintf(stderr, "Error: Could not allocate t_q_matrix structure\n");
    return NULL;
  }

  mat->data = (struct t_complex *)calloc(size, sizeof(struct t_complex));
  if (mat->data == NULL) {
    fprintf(stderr, "Error: Could not allocate matrix data\n");
    return NULL;
  }

  mat->rows = rows;
  mat->cols = cols;

  return mat;
}

/**
 * Free memory allocated for a quantum matrix
 * @param mat Matrix to free
 */
void q_matrix_free(struct t_q_matrix *mat) {
  if (mat) {
    if (mat->data) {
      free(mat->data);
    }
    free(mat);
  }
}

#define BLOCK_SIZE 64

/**
 * Apply a quantum gate matrix to a quantum state vector
 * @param state Quantum state vector
 * @param gate Gate matrix to apply
 */
void q_gate_apply(struct t_q_state *state, const struct t_q_matrix *gate) {
  struct t_complex *new_vector = state->scratch_vector;
  struct t_complex *vector = state->vector;
  struct t_complex *temp;

  long N = state->size;
  long i, j;
  long ii, jj;
  long N_block = 0;

  if (gate->cols != N || gate->rows != N) {
    fprintf(stderr, "Error: Gate dimensions (%dx%d) mismatch size (%ld)\n",
            gate->rows, gate->cols, N);
    return;
  }

  for (i = 0; i < N; i++) {
    new_vector[i] = c_zero();
  }

  for (ii = 0; ii < N; ii += BLOCK_SIZE) {
    N_block = ((ii + BLOCK_SIZE) < N) ? BLOCK_SIZE : (N - ii);
    for (jj = 0; jj < N; jj += BLOCK_SIZE) {
      for (i = ii; i < ii + N_block; i++) {
        for (j = jj; j < jj + BLOCK_SIZE; j++) {
          if (j < N) {
            new_vector[i] =
                c_add(new_vector[i], c_mul(gate->data[i * N + j], vector[j]));
          }
        }
      }
    }
  }

  temp = state->vector;
  state->vector = new_vector;
  state->scratch_vector = temp;
}
/* ------------------------------------------------------------------------- */
/* q_state.c implementation                                         */
/* ------------------------------------------------------------------------- */

#define CACHE_LINE_SIZE 64

#ifdef QCS_MULTI_THREAD
extern thread_pool_t *pool;
#endif

/**
 * Worker function for parallel state initialization
 * @param arg Thread arguments containing state and range
 */
static void q_state_init_worker(void *arg) {
  struct t_thread_args *args = (struct t_thread_args *)arg;
  long i;

  for (i = args->start; i < args->end; i++) {
    args->state->vector[i] = c_zero();
    args->state->scratch_vector[i] = c_zero();
  }
  free(args);
}

/**
 * Initialize a quantum state vector with specified number of qubits
 * @param num_qubits Number of qubits in the system
 * @return Pointer to allocated state or NULL on failure
 */
struct t_q_state *q_state_init(int num_qubits) {
  struct t_q_state *state;
  long size;
  int i;
  int ret;

  if (num_qubits <= 0) {
    fprintf(stderr, "Error: Number of qubits must be positive.\n");
    return NULL;
  }

  size = 1L << num_qubits;
  state = (struct t_q_state *)malloc(sizeof(struct t_q_state));
  if (state == NULL) {
    return NULL;
  }

  ret = posix_memalign((void **)&state->vector, CACHE_LINE_SIZE,
                       size * sizeof(struct t_complex));
  if (ret != 0) {
    fprintf(stderr,
            "Error: Aligned memory allocation failed for state vector.\n");
    free(state);
    return NULL;
  }

  ret = posix_memalign((void **)&state->scratch_vector, CACHE_LINE_SIZE,
                       size * sizeof(struct t_complex));
  if (ret != 0) {
    fprintf(stderr,
            "Error: Aligned memory allocation failed for scratch vector.\n");
    free(state->vector);
    free(state);
    return NULL;
  }

  state->qubits_num = num_qubits;
  state->size = size;

#ifdef QCS_MULTI_THREAD
  for (i = 0; i < pool->num_threads; i++) {
    long start, end;

    get_thread_work_range(size, pool->num_threads, i, &start, &end);

    struct t_thread_args *args = malloc(sizeof(struct t_thread_args));
    if (args == NULL) {
      fprintf(stderr,
              "Error: Failed to allocate memory for thread arguments.\n");
      exit(EXIT_FAILURE);
    }

    args->start = start;
    args->end = end;
    args->state = state;

    thread_pool_add_task(pool, q_state_init_worker, args);
  }

  thread_pool_wait(pool);
#else
  for (i = 0; i < size; i++) {
    state->vector[i] = c_zero();
    state->scratch_vector[i] = c_zero();
  }
#endif

  state->vector[0] = c_one();
  return state;
}

/**
 * Free memory allocated for a quantum state
 * @param state State to free
 */
void q_state_free(struct t_q_state *state) {
  if (state) {
    if (state->vector)
      free(state->vector);
    if (state->scratch_vector)
      free(state->scratch_vector);
    free(state);
  }
}

/**
 * Set quantum state to a specific basis state
 * @param state Quantum state to modify
 * @param index_basis Basis state index
 */
void q_state_set_basis(struct t_q_state *state, int index_basis) {
  long i;
  if (state == NULL || index_basis < 0 || index_basis >= state->size) {
    fprintf(stderr, "Error: Invalid state or basis index\n");
    return;
  }
  for (i = 0; i < state->size; i++) {
    state->vector[i] = c_zero();
  }
  state->vector[index_basis] = c_one();
}

/**
 * Print quantum state vector with optional solution highlighting
 * @param state Quantum state to print
 * @param solution_index Index to highlight (or -1 for none)
 */
void q_state_print(const struct t_q_state *state, int solution_index) {
  long i;
  int max_print = state->size > 8 ? 4 : state->size;

  printf("--- Quantum State (%d Qubits) ---\n", state->qubits_num);

  for (i = 0; i < max_print; i++) {
    printf("|%ld>: %f + i%f%s\n", i, state->vector[i].number_real,
           state->vector[i].number_imaginary,
           i == solution_index ? " <-- SOLUTION" : "");
  }

  if (solution_index >= max_print && solution_index < state->size - 1) {
    printf("...\n");
    printf("|%d>: %f + i%f <-- SOLUTION\n", solution_index,
           state->vector[solution_index].number_real,
           state->vector[solution_index].number_imaginary);
  }

  if (state->size > max_print) {
    printf("...\n");
    long last_index = state->size - 1;
    printf("|%ld>: %f + i%f%s\n", last_index,
           state->vector[last_index].number_real,
           state->vector[last_index].number_imaginary,
           last_index == solution_index ? " <-- SOLUTION" : "");
  }

  printf("----------------------------------\n");
}
/* ------------------------------------------------------------------------- */
/* qcs.c implementation                                         */
/* ------------------------------------------------------------------------- */

#ifdef QCS_MULTI_THREAD
thread_pool_t *pool = NULL;
#endif

struct t_q_circuit {
  int num_qubits;
  int num_gates;
  struct t_q_state *state;
  char **gate_history;
  int *target_qubits;
  int *control_qubits;
  double *parameters;
  int history_size;
  int history_capacity;
};

/**
 * Create a new quantum circuit with specified number of qubits
 * @param num_qubits Number of qubits in the circuit
 * @return Pointer to created circuit or NULL on failure
 */
t_q_circuit *qc_create(int num_qubits) {
  #ifdef QCS_MULTI_THREAD
  if (pool == NULL) {
    long num_cores = sysconf(_SC_NPROCESSORS_ONLN);

    if (num_cores < 1)
      num_cores = 2;

    int effective_threads = (num_cores > 4) ? 4 : num_cores;
    pool = thread_pool_create(effective_threads, 16);

    if (pool == NULL) {
      fprintf(stderr, "Error: Could not create thread pool.\n");
      return NULL;
    }
  }
  #endif

  t_q_circuit *circuit = (t_q_circuit *)malloc(sizeof(t_q_circuit));
  if (!circuit)
    return NULL;

  circuit->num_qubits = num_qubits;
  circuit->num_gates = 0;
  circuit->state = q_state_init(num_qubits);
  circuit->history_size = 0;
  circuit->history_capacity = 100;

  circuit->gate_history =
      (char **)malloc(circuit->history_capacity * sizeof(char *));
  circuit->target_qubits =
      (int *)malloc(circuit->history_capacity * sizeof(int));
  circuit->control_qubits =
      (int *)malloc(circuit->history_capacity * sizeof(int));
  circuit->parameters =
      (double *)malloc(circuit->history_capacity * sizeof(double));

  return circuit;
}

/**
 * Destroy a quantum circuit and free all associated memory
 * @param circuit Circuit to destroy
 */
void qc_destroy(t_q_circuit *circuit) {
  #ifdef QCS_MULTI_THREAD
  if (pool != NULL) {
    thread_pool_destroy(pool);
    pool = NULL;
  }
  #endif

  int i;

  if (circuit) {
    if (circuit->state)
      q_state_free(circuit->state);
    if (circuit->gate_history) {
      for (i = 0; i < circuit->history_size; i++) {
        free(circuit->gate_history[i]);
      }
      free(circuit->gate_history);
    }
    if (circuit->target_qubits)
      free(circuit->target_qubits);
    if (circuit->control_qubits)
      free(circuit->control_qubits);
    if (circuit->parameters)
      free(circuit->parameters);
    free(circuit);
  }
}


/**
 * Duplicate a string with memory allocation
 * @param str String to duplicate
 * @return Duplicated string or NULL on failure
 */
static char *qc_strdup(const char *str) {
  size_t len;
  char *copy;
  
  if (str == NULL)
    return NULL;

  len = strlen(str) + 1;
  copy = (char *)malloc(len);
  if (copy) {
    memcpy(copy, str, len);
  }
  return copy;
}

/**
 * Add a gate to the circuit history
 * @param circuit Quantum circuit
 * @param gate_name Name of the gate
 * @param target Target qubit index
 * @param control Control qubit index (or -1 if none)
 * @param param Gate parameter value
 */
void qc_add_gate(t_q_circuit *circuit, const char *gate_name, int target,
                 int control, double param) {
  if (circuit->history_size >= circuit->history_capacity) {
    circuit->history_capacity *= 2;
    circuit->gate_history = (char **)realloc(
        circuit->gate_history, circuit->history_capacity * sizeof(char *));
    circuit->target_qubits = (int *)realloc(
        circuit->target_qubits, circuit->history_capacity * sizeof(int));
    circuit->control_qubits = (int *)realloc(
        circuit->control_qubits, circuit->history_capacity * sizeof(int));
    circuit->parameters = (double *)realloc(
        circuit->parameters, circuit->history_capacity * sizeof(double));
  }

  circuit->gate_history[circuit->history_size] = qc_strdup(gate_name);
  circuit->target_qubits[circuit->history_size] = target;
  circuit->control_qubits[circuit->history_size] = control;
  circuit->parameters[circuit->history_size] = param;
  circuit->history_size++;
  circuit->num_gates++;
}

/**
 * Apply Hadamard gate to specified qubit
 * @param circuit Quantum circuit
 * @param qubit Target qubit index
 */
void qc_h(t_q_circuit *circuit, int qubit) {
  struct t_q_matrix *H = q_gate_H();
  q_apply_1q_gate(circuit->state, H, qubit);
  q_matrix_free(H);
  qc_add_gate(circuit, "H", qubit, -1, 0.0);
}

/**
 * Apply X (Pauli-X) gate to specified qubit
 * @param circuit Quantum circuit
 * @param qubit Target qubit index
 */
void qc_x(t_q_circuit *circuit, int qubit) {
  struct t_q_matrix *X = q_gate_X();
  q_apply_1q_gate(circuit->state, X, qubit);
  q_matrix_free(X);
  qc_add_gate(circuit, "X", qubit, -1, 0.0);
}

/**
 * Apply CNOT (controlled-X) gate
 * @param circuit Quantum circuit
 * @param control Control qubit index
 * @param target Target qubit index
 */
void qc_cnot(t_q_circuit *circuit, int control, int target) {
  struct t_q_matrix *X = q_gate_X();

  q_apply_2q_gate(circuit->state, X, control, target);
  q_matrix_free(X);
  qc_add_gate(circuit, "CNOT", target, control, 0.0);
}

/**
 * Apply RX (rotation around X-axis) gate to specified qubit
 * @param circuit Quantum circuit
 * @param qubit Target qubit index
 * @param angle Rotation angle in radians
 */
void qc_rx(t_q_circuit *circuit, int qubit, double angle) {
  struct t_q_matrix *RX = q_gate_RX(angle);
  q_apply_1q_gate(circuit->state, RX, qubit);
  q_matrix_free(RX);
  qc_add_gate(circuit, "RX", qubit, -1, angle);
}

/**
 * Apply RY (rotation around Y-axis) gate to specified qubit
 * @param circuit Quantum circuit
 * @param qubit Target qubit index
 * @param angle Rotation angle in radians
 */
void qc_ry(t_q_circuit *circuit, int qubit, double angle) {
  struct t_q_matrix *RY = q_gate_RY(angle);
  q_apply_1q_gate(circuit->state, RY, qubit);
  q_matrix_free(RY);
  qc_add_gate(circuit, "RY", qubit, -1, angle);
}

/**
 * Apply RZ (rotation around Z-axis) gate to specified qubit
 * @param circuit Quantum circuit
 * @param qubit Target qubit index
 * @param angle Rotation angle in radians
 */
void qc_rz(t_q_circuit *circuit, int qubit, double angle) {
  struct t_q_matrix *RZ = q_gate_RZ(angle);
  q_apply_1q_gate(circuit->state, RZ, qubit);
  q_matrix_free(RZ);
  qc_add_gate(circuit, "RZ", qubit, -1, angle);
}

/**
 * Measure a single qubit and collapse the quantum state
 * @param circuit Quantum circuit
 * @param qubit Qubit to measure
 * @return Measured value (0 or 1)
 */
int qc_measure(t_q_circuit *circuit, int qubit) {
  long state_size;
  double prob_0;
  long i;
  double amp_real;
  double amp_imag;
  double random_val;

  if (circuit == NULL || circuit->state == NULL || qubit < 0 ||
      qubit >= circuit->num_qubits) {
    return 0;
  }

  state_size = circuit->state->size;
  prob_0 = 0.0;

  for (i = 0; i < state_size; i++) {
    if ((i & (1L << qubit)) == 0) {
      amp_real = circuit->state->vector[i].number_real;
      amp_imag = circuit->state->vector[i].number_imaginary;
      prob_0 += (amp_real * amp_real) + (amp_imag * amp_imag);
    }
  }

  random_val = rand() / (double)RAND_MAX;

  if (random_val <= prob_0) {
    for (i = 0; i < state_size; i++) {
      if ((i & (1L << qubit)) != 0) {
        circuit->state->vector[i].number_real = 0.0;
        circuit->state->vector[i].number_imaginary = 0.0;
      }
    }
    q_state_normalize(circuit->state);
    return 0;

  } else {
    for (i = 0; i < state_size; i++) {
      if ((i & (1L << qubit)) == 0) {
        circuit->state->vector[i].number_real = 0.0;
        circuit->state->vector[i].number_imaginary = 0.0;
      }
    }

    q_state_normalize(circuit->state);
    return 1;
  }
}

/**
 * Measure all qubits in the circuit
 * @param circuit Quantum circuit
 * @param results Array to store measurement results
 */
void qc_measure_all(t_q_circuit *circuit, int *results) {
  if (circuit == NULL || results == NULL)
    return;

  int i;

  for (i = 0; i < circuit->num_qubits; i++) {
    results[i] = qc_measure(circuit, i);
  }

  qc_add_gate(circuit, "MEASURE", -1, -1, 0.0);
}

/**
 * Print the quantum circuit gate history
 * @param circuit Quantum circuit to print
 */
void qc_print_circuit(t_q_circuit *circuit) {
  int q;
  int g;
  int has_measurement;

  printf("\n╔══════════════════════════════════════════╗\n");
  printf("║              QUANTUM CIRCUIT             ║\n");
  printf("╚══════════════════════════════════════════╝\n");
  printf("Qubits: %d | Gates: %d\n\n", circuit->num_qubits, circuit->num_gates);

  has_measurement = 0;

  for (g = 0; g < circuit->history_size; g++) {
    if (strcmp(circuit->gate_history[g], "MEASURE") == 0) {
      has_measurement = 1;
      break;
    }
  }

  for (q = 0; q < circuit->num_qubits; q++) {
    printf("q%-2d ", q);

    for (g = 0; g < circuit->history_size; g++) {
      const char *gate = circuit->gate_history[g];
      int target = circuit->target_qubits[g];
      int control = circuit->control_qubits[g];

      if (strcmp(gate, "H") == 0 && target == q) {
        printf("─H─");
      } else if (strcmp(gate, "X") == 0 && target == q) {
        printf("─X─");
      } else if (strcmp(gate, "CNOT") == 0) {
        if (control == q)
          printf("─∙─");
        else if (target == q)
          printf("─⊕─");
        else
          printf("───");
      } else {
        printf("───");
      }

      if (g < circuit->history_size - 1)
        printf("─");
    }
    if (!has_measurement) {
      printf("─M─");
    }
    printf("─┐\n");
  }

  printf("\nGATE SEQUENCE: ");
  for (g = 0; g < circuit->history_size; g++) {
    const char *gate = circuit->gate_history[g];
    int target = circuit->target_qubits[g];
    int control = circuit->control_qubits[g];

    if (strcmp(gate, "CNOT") == 0) {
      printf("CNOT(%d,%d) ", control, target);
    } else if (strcmp(gate, "MEASURE") == 0) {
      printf("MEASURE ");
    } else {
      printf("%s(%d) ", gate, target);
    }
  }
  printf("\n\n");
}

/**
 * Print the quantum state vector
 * @param circuit Quantum circuit
 * @param solution_index Index to highlight (or -1 for none)
 */
void qc_print_state(t_q_circuit *circuit, int solution_index) {
  q_state_print(circuit->state, solution_index);
}

/**
 * Get the probability amplitude for a specific quantum state
 * @param circuit Quantum circuit
 * @param state State index
 * @return Probability amplitude (0.0 to 1.0)
 */
double qc_get_probability(t_q_circuit *circuit, int state) {
  if (state < 0 || state >= circuit->state->size)
    return 0.0;
  return c_norm_sq(circuit->state->vector[state]);
}

/**
 * Apply Grover's search algorithm to find a specific quantum state
 * @param circuit Quantum circuit
 * @param solution_state Target state to search for
 */
void qc_grover_search(t_q_circuit *circuit, int solution_state) {
  int q;
  int i;
  int num_qubits = circuit->num_qubits;
  int iterations = q_grover_iterations(num_qubits);

  for (q = 0; q < circuit->num_qubits; q++) {
    qc_h(circuit, q);
  }

  for (i = 0; i < iterations; i++) {
    q_apply_phase_flip(circuit->state, solution_state);
    qc_add_gate(circuit, "ORACLE", solution_state, -1, 0.0);

    q_apply_diffusion(circuit->state);
    qc_add_gate(circuit, "DIFFUSION", -1, -1, 0.0);
  }
}

int qc_get_num_qubits(t_q_circuit *circuit) { return circuit->num_qubits; }
int qc_get_num_gates(t_q_circuit *circuit) { return circuit->num_gates; }

/**
 * Apply controlled phase gate
 * @param circuit Quantum circuit
 * @param control Control qubit index
 * @param target Target qubit index
 * @param angle Phase angle in radians
 */
void qc_cphase(t_q_circuit *circuit, int control, int target, double angle) {
  struct t_q_matrix *CP = q_gate_CP(angle);

  q_apply_2q_gate(circuit->state, CP, control, target);
  q_matrix_free(CP);
  qc_add_gate(circuit, "CPHASE", target, control, angle);
}

/**
 * Apply quantum Fourier transform to the circuit
 * @param circuit Quantum circuit
 */
void qc_quantum_fourier_transform(t_q_circuit *circuit) {
  double const m_pi = (3.14159265358979323846);

  int n = circuit->num_qubits;
  int i, j;

  for (i = 0; i < n; i++) {
    qc_h(circuit, i);

    for (j = i + 1; j < n; j++) {
      double angle = m_pi / (double)(1 << (j - i));
      qc_cphase(circuit, j, i, angle);
    }
  }
}

/**
 * Find the quantum state with the highest probability amplitude
 * @param circuit Quantum circuit
 * @return Index of the most likely state
 */
int qc_find_most_likely_state(t_q_circuit *circuit) {
  long max_idx = 0;
  double max_prob = 0.0;
  long num_states = circuit->state->size;
  long i;

  for (i = 0; i < num_states; i++) {
    double prob = qc_get_probability(circuit, i);
    if (prob > max_prob) {
      max_prob = prob;
      max_idx = i;
    }
  }
  return (int)max_idx;
}

/**
 * Apply Y (Pauli-Y) gate to specified qubit
 * @param circuit Quantum circuit
 * @param qubit Target qubit index
 */
void qc_y(t_q_circuit *circuit, int qubit) {
  struct t_q_matrix *Y = q_gate_Y();
  q_apply_1q_gate(circuit->state, Y, qubit);
  q_matrix_free(Y);
  qc_add_gate(circuit, "Y", qubit, -1, 0.0);
}

/**
 * Apply Z (Pauli-Z) gate to specified qubit
 * @param circuit Quantum circuit
 * @param qubit Target qubit index
 */
void qc_z(t_q_circuit *circuit, int qubit) {
  struct t_q_matrix *Z = q_gate_Z();
  q_apply_1q_gate(circuit->state, Z, qubit);
  q_matrix_free(Z);
  qc_add_gate(circuit, "Z", qubit, -1, 0.0);
}

/**
 * Apply phase gate to specified qubit
 * @param circuit Quantum circuit
 * @param qubit Target qubit index
 * @param angle Phase angle in radians
 */
void qc_phase(t_q_circuit *circuit, int qubit, double angle) {
  struct t_q_matrix *P = q_gate_P(angle);
  q_apply_1q_gate(circuit->state, P, qubit);
  q_matrix_free(P);
  qc_add_gate(circuit, "P", qubit, -1, angle);
}

/**
 * Create a GHZ (Greenberger-Horne-Zeilinger) entangled state
 * @param circuit Quantum circuit
 */
void qc_ghz_state(t_q_circuit *circuit) {
  int n = circuit->num_qubits;
  int i;

  if (n < 2) {
    fprintf(stderr, "Error: GHZ state requires at least 2 qubits.\n");
    return;
  }

  qc_h(circuit, 0);

  for (i = 0; i < n - 1; i++) {
    qc_cnot(circuit, i, i + 1);
  }
}

/**
 * Add a barrier to the quantum circuit
 * @param circuit Quantum circuit
 */
void qc_barrier(t_q_circuit *circuit) {
  qc_add_gate(circuit, "BARRIER", -1, -1, 0.0);
}

/**
 * Reset a qubit to the |0⟩ state
 * @param circuit Quantum circuit
 * @param qubit Qubit to reset
 */
void qc_reset(t_q_circuit *circuit, int qubit) {
  if (qc_measure(circuit, qubit) == 1) {
    qc_x(circuit, qubit);
  }
  qc_add_gate(circuit, "RESET", qubit, -1, 0.0);
}

/**
 * Run the quantum circuit and perform final measurements
 * @param circuit Quantum circuit
 */
void qc_run(t_q_circuit *circuit) {
  int *results = malloc(circuit->num_qubits * sizeof(int));
  if (results) {
    qc_measure_all(circuit, results);
    free(results);
  }
}

/**
 * Run multiple shots of the quantum circuit
 * @param circuit Quantum circuit
 * @param shots Number of shots to run
 * @param results Array to store shot results
 */
void qc_run_shots(t_q_circuit *circuit, int shots, int *results) {
  long i;
  int s;
  long num_states;
  double *probabilities;

  if (!circuit || shots <= 0 || !results)
    return;

  num_states = circuit->state->size;
  probabilities = malloc(num_states * sizeof(double));
  if (!probabilities)
    return;

  for (i = 0; i < num_states; i++) {
    probabilities[i] = qc_get_probability(circuit, i);
  }

  memset(results, 0, num_states * sizeof(int));

  for (s = 0; s < shots; s++) {
    double rand_val = rand() / (double)RAND_MAX;
    double cumulative_prob = 0.0;
    for (i = 0; i < num_states; i++) {
      cumulative_prob += probabilities[i];
      if (rand_val < cumulative_prob) {
        results[i]++;
        break;
      }
    }
  }
  free(probabilities);
}

/**
 * Implement Bernstein-Vazirani algorithm
 * @param circuit Quantum circuit
 * @param hidden_string Hidden string to find
 */
void qc_bernstein_vazirani(t_q_circuit *circuit, int hidden_string) {
  int n = circuit->num_qubits - 1;
  int i;

  if (n <= 0) {
    fprintf(stderr, "Bernstein-Vazirani requires at least 2 qubits (1 input + "
                    "1 ancilla).\n");
    return;
  }

  qc_x(circuit, n);
  qc_h(circuit, n);

  for (i = 0; i < n; i++) {
    qc_h(circuit, i);
  }

  qc_barrier(circuit);

  for (i = 0; i < n; i++) {
    if ((hidden_string >> i) & 1) {
      qc_cnot(circuit, i, n);
    }
  }

  qc_barrier(circuit);

  for (i = 0; i < n; i++) {
    qc_h(circuit, i);
  }
}

/**
 * Optimize the quantum circuit by removing redundant gates
 * @param circuit Quantum circuit to optimize
 */
void qc_optimize(t_q_circuit *circuit) {
  int i;
  char *gate1_name;
  int target1;
  int control1;
  char *gate2_name;
  int target2;
  int control2;
  int single_qubit_cancel;
  int cnot_cancel;
  int j;

  i = 0;
  while (i < circuit->history_size - 1) {
    gate1_name = circuit->gate_history[i];
    target1 = circuit->target_qubits[i];
    control1 = circuit->control_qubits[i];

    gate2_name = circuit->gate_history[i + 1];
    target2 = circuit->target_qubits[i + 1];
    control2 = circuit->control_qubits[i + 1];

    single_qubit_cancel =
        (target1 == target2) && (strcmp(gate1_name, gate2_name) == 0) &&
        (strcmp(gate1_name, "H") == 0 || strcmp(gate1_name, "X") == 0 ||
         strcmp(gate1_name, "Y") == 0 || strcmp(gate1_name, "Z") == 0);

    cnot_cancel = (strcmp(gate1_name, "CNOT") == 0) &&
                  (strcmp(gate2_name, "CNOT") == 0) &&
                  (target1 == target2) && (control1 == control2);

    if (single_qubit_cancel || cnot_cancel) {
      free(circuit->gate_history[i]);
      free(circuit->gate_history[i + 1]);
      for (j = i; j < circuit->history_size - 2; j++) {
        circuit->gate_history[j] = circuit->gate_history[j + 2];
        circuit->target_qubits[j] = circuit->target_qubits[j + 2];
        circuit->control_qubits[j] = circuit->control_qubits[j + 2];
        circuit->parameters[j] = circuit->parameters[j + 2];
      }
      circuit->history_size -= 2;
      circuit->num_gates -= 2;

      i = 0;
    } else {
      i++;
    }
  }
}
/* ------------------------------------------------------------------------- */
/* thread_pools.c implementation                                         */
/* ------------------------------------------------------------------------- */

static void *worker_thread_function(void *pool_ptr);

/**
 * Calculate work range for a thread in parallel processing
 * @param total_size Total number of elements to process
 * @param num_threads Number of threads
 * @param thread_id Current thread ID
 * @param start Output start index for this thread
 * @param end Output end index for this thread
 */
void get_thread_work_range(long total_size, int num_threads, int thread_id,
                           long *start, long *end) {
  long chunk_size = total_size / num_threads;
  *start = thread_id * chunk_size;
  *end = (thread_id == num_threads - 1) ? total_size : (*start) + chunk_size;
}

/**
 * Create a thread pool for parallel processing
 * @param num_threads Number of worker threads
 * @param queue_size Size of task queue
 * @return Pointer to created thread pool or NULL on failure
 */
thread_pool_t *thread_pool_create(int num_threads, int queue_size) {
  thread_pool_t *pool;
  int i;

  if (num_threads <= 0 || queue_size <= 0) {
    return NULL;
  }

  pool = (thread_pool_t *)malloc(sizeof(thread_pool_t));
  if (pool == NULL) {
    return NULL;
  }

  pool->num_threads = num_threads;
  pool->queue_size = queue_size;
  pool->head = pool->tail = pool->task_count = pool->active_tasks = 0;
  pool->shutdown = 0;

  pool->threads = (pthread_t *)malloc(sizeof(pthread_t) * num_threads);
  pool->task_queue =
      (struct t_task *)malloc(sizeof(struct t_task) * queue_size);

  if (pool->threads == NULL || pool->task_queue == NULL) {
    if (pool->threads)
      free(pool->threads);
    if (pool->task_queue)
      free(pool->task_queue);
    free(pool);
    return NULL;
  }

  pthread_mutex_init(&(pool->lock), NULL);
  pthread_cond_init(&(pool->notify), NULL);
  pthread_cond_init(&(pool->all_tasks_done), NULL);

  for (i = 0; i < num_threads; i++) {
    pthread_create(&(pool->threads[i]), NULL, worker_thread_function, pool);
  }

  return pool;
}

int thread_pool_add_task(thread_pool_t *pool, void (*function)(void *),
                         void *arg) {
  pthread_mutex_lock(&(pool->lock));

  if (pool->task_count == pool->queue_size) {
    pthread_mutex_unlock(&(pool->lock));
    fprintf(stderr, "Error: Thread pool task queue is full.\n");
    return -1;
  }

  pool->task_queue[pool->tail].function = function;
  pool->task_queue[pool->tail].argument = arg;
  pool->tail = (pool->tail + 1) % pool->queue_size;
  pool->task_count++;
  pool->active_tasks++;

  pthread_cond_broadcast(&(pool->notify));
  pthread_mutex_unlock(&(pool->lock));

  return 0;
}

/**
 * Wait for all tasks in thread pool to complete
 * @param pool Thread pool to wait for
 */
void thread_pool_wait(thread_pool_t *pool) {
  pthread_mutex_lock(&(pool->lock));

  while (pool->task_count > 0 || pool->active_tasks > 0) {
    pthread_cond_wait(&(pool->all_tasks_done), &(pool->lock));
  }

  pthread_mutex_unlock(&(pool->lock));
}

/**
 * Destroy thread pool and free all associated resources
 * @param pool Thread pool to destroy
 * @return 0 on success, -1 on failure
 */
int thread_pool_destroy(thread_pool_t *pool) {
  int i;

  pthread_mutex_lock(&(pool->lock));

  pool->shutdown = 1;

  pthread_cond_broadcast(&(pool->notify));
  pthread_mutex_unlock(&(pool->lock));

  for (i = 0; i < pool->num_threads; i++) {
    pthread_join(pool->threads[i], NULL);
  }

  free(pool->threads);
  free(pool->task_queue);

  pthread_mutex_destroy(&(pool->lock));
  pthread_cond_destroy(&(pool->notify));
  pthread_cond_destroy(&(pool->all_tasks_done));

  free(pool);

  return 0;
}

/**
 * Worker thread function that processes tasks from the queue
 * @param pool_ptr Pointer to thread pool
 * @return NULL on exit
 */
static void *worker_thread_function(void *pool_ptr) {
  thread_pool_t *pool = (thread_pool_t *)pool_ptr;
  struct t_task task;

  while (1) {
    pthread_mutex_lock(&(pool->lock));

    while (pool->task_count == 0 && !pool->shutdown) {
      pthread_cond_wait(&(pool->notify), &(pool->lock));
    }

    if (pool->shutdown) {
      pthread_mutex_unlock(&(pool->lock));
      break;
    }

    task.function = pool->task_queue[pool->head].function;
    task.argument = pool->task_queue[pool->head].argument;

    pool->head = (pool->head + 1) % pool->queue_size;
    pool->task_count--;

    pthread_mutex_unlock(&(pool->lock));

    (*(task.function))(task.argument);

    pthread_mutex_lock(&(pool->lock));

    pool->active_tasks--;

    if (pool->active_tasks == 0 && pool->task_count == 0) {
      pthread_cond_signal(&(pool->all_tasks_done));
    }

    pthread_mutex_unlock(&(pool->lock));
  }

  pthread_exit(NULL);
  return NULL;
}
/* ------------------------------------------------------------------------- */
/* q_gates.c implementation                                         */
/* ------------------------------------------------------------------------- */

#ifdef QCS_MULTI_THREAD
static void q_apply_1q_gate_worker(void *arg);
static void q_apply_2q_gate_worker(void *arg);
#endif

#ifdef QCS_GPU_OPENCL
void q_apply_1q_gate_gpu(struct t_q_state *state, const struct t_q_matrix *gate, int target_qubit);
void q_apply_2q_gate_gpu(struct t_q_state *state, const struct t_q_matrix *gate, 
                         int control_qubit, int target_qubit);
#endif

/**
 * Apply a 1-qubit quantum gate to the quantum state
 * @param state Quantum state vector
 * @param gate 2x2 gate matrix
 * @param target_qubit Target qubit index
 */
void q_apply_1q_gate(struct t_q_state *state, const struct t_q_matrix *gate,
                     int target_qubit) {
  long size = state->size;
  long step = 1L << target_qubit;
  long block_size = 1L << (target_qubit + 1);
  long i, j;

  if (state == NULL || gate == NULL || target_qubit < 0 ||
      target_qubit >= state->qubits_num) {
    fprintf(stderr, "Error: Invalid arguments for 1-qubit gate application.\n");
    return;
  }

  #ifdef QCS_GPU_OPENCL
    q_apply_1q_gate_gpu(state, gate, target_qubit);
  #elif defined(QCS_CPU_OPENMP)
    c_copy_simd(state->scratch_vector, state->vector, size);
    
    #ifdef _OPENMP
    #pragma omp parallel for
    for (i = 0; i < size; i += block_size) {
        for (j = i; j < i + step; j++) {
            long index0 = j;
            long index1 = j + step;
            struct t_complex v0 = state->vector[index0];
            struct t_complex v1 = state->vector[index1];

            state->scratch_vector[index0] = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
            state->scratch_vector[index1] = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
        }
    }
    #else
    for (i = 0; i < size; i += block_size) {
        for (j = i; j < i + step; j++) {
            long index0 = j;
            long index1 = j + step;
            struct t_complex v0 = state->vector[index0];
            struct t_complex v1 = state->vector[index1];

            state->scratch_vector[index0] = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
            state->scratch_vector[index1] = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
        }
    }
    #endif
    
  #elif defined(QCS_GPU_OPENCL)
    c_copy_gpu_real(state->scratch_vector, state->vector, size);
    
    for (i = 0; i < size; i += block_size) {
        for (j = i; j < i + step; j++) {
            long index0 = j;
            long index1 = j + step;
            struct t_complex v0 = state->vector[index0];
            struct t_complex v1 = state->vector[index1];

            state->scratch_vector[index0] = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
            state->scratch_vector[index1] = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
        }
    }
    
  #elif defined(QCS_SIMD_ONLY)
    c_copy_simd(state->scratch_vector, state->vector, size);
    
    for (i = 0; i < size; i += block_size) {
        for (j = i; j < i + step; j++) {
            long index0 = j;
            long index1 = j + step;
            struct t_complex v0 = state->vector[index0];
            struct t_complex v1 = state->vector[index1];

            state->scratch_vector[index0] = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
            state->scratch_vector[index1] = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
        }
    }
    
  #elif defined(QCS_MULTI_THREAD)
    extern thread_pool_t *pool;
    
    memcpy(state->scratch_vector, state->vector, size * sizeof(struct t_complex));

    int effective_threads = (pool->num_threads > 4) ? 4 : pool->num_threads;
    long num_blocks = size / block_size;
    long blocks_per_thread = (num_blocks + effective_threads - 1) / effective_threads;
    int k;

    for (k = 0; k < effective_threads; k++) {
        long start_block = k * blocks_per_thread;
        long end_block = (k + 1) * blocks_per_thread;
        if (end_block > num_blocks) end_block = num_blocks;
        
        if (start_block >= end_block) break;

        struct t_thread_args *args = malloc(sizeof(struct t_thread_args));
        if (!args) exit(EXIT_FAILURE);

        args->start = start_block * block_size;
        args->end = end_block * block_size;
        args->state = state;
        args->gate = gate;
        args->target_qubit = target_qubit;

        thread_pool_add_task(pool, q_apply_1q_gate_worker, args);
    }
    thread_pool_wait(pool);
    
  #else
    memcpy(state->scratch_vector, state->vector, size * sizeof(struct t_complex));

    for (i = 0; i < size; i += block_size) {
        for (j = i; j < i + step; j++) {
            long index0 = j;
            long index1 = j + step;
            struct t_complex v0 = state->vector[index0];
            struct t_complex v1 = state->vector[index1];

            state->scratch_vector[index0] = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
            state->scratch_vector[index1] = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
        }
    }
  #endif

  struct t_complex *temp = state->vector;
  state->vector = state->scratch_vector;
  state->scratch_vector = temp;
}

/**
 * Apply a 2-qubit quantum gate to the quantum state
 * @param state Quantum state vector
 * @param gate 4x4 gate matrix
 * @param control_qubit Control qubit index
 * @param target_qubit Target qubit index
 */
void q_apply_2q_gate(struct t_q_state *state, const struct t_q_matrix *gate,
                     int control_qubit, int target_qubit) {
  long size = state->size;
  long c_bit = 1L << control_qubit;
  long t_bit = 1L << target_qubit;
  long i;

  if (state == NULL || gate == NULL || control_qubit < 0 || target_qubit < 0 ||
      control_qubit >= state->qubits_num || target_qubit >= state->qubits_num ||
      control_qubit == target_qubit) {
    fprintf(stderr, "Error: Invalid arguments for 2-qubit gate application.\n");
    return;
  }

  #ifdef QCS_GPU_OPENCL
    q_apply_2q_gate_gpu(state, gate, control_qubit, target_qubit);
  #elif defined(QCS_CPU_OPENMP)
    c_copy_simd(state->scratch_vector, state->vector, size);
    
    #ifdef _OPENMP
    #pragma omp parallel for
    for (i = 0; i < size; i++) {
        if ((i & c_bit) != 0 && (i & t_bit) == 0) {
            long index0 = i;
            long index1 = i | t_bit;

            struct t_complex v0 = state->vector[index0];
            struct t_complex v1 = state->vector[index1];

            state->scratch_vector[index0] = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
            state->scratch_vector[index1] = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
        } else {
            state->scratch_vector[i] = state->vector[i];
        }
    }
    #else
    for (i = 0; i < size; i++) {
        if ((i & c_bit) != 0 && (i & t_bit) == 0) {
            long index0 = i;
            long index1 = i | t_bit;

            struct t_complex v0 = state->vector[index0];
            struct t_complex v1 = state->vector[index1];

            state->scratch_vector[index0] = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
            state->scratch_vector[index1] = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
        } else {
            state->scratch_vector[i] = state->vector[i];
        }
    }
    #endif
    
  #elif defined(QCS_GPU_OPENCL)
    c_copy_gpu_real(state->scratch_vector, state->vector, size);
    
    for (i = 0; i < size; i++) {
        if ((i & c_bit) != 0 && (i & t_bit) == 0) {
            long index0 = i;
            long index1 = i | t_bit;

            struct t_complex v0 = state->vector[index0];
            struct t_complex v1 = state->vector[index1];

            state->scratch_vector[index0] = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
            state->scratch_vector[index1] = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
        } else {
            state->scratch_vector[i] = state->vector[i];
        }
    }
    
  #elif defined(QCS_SIMD_ONLY)
    c_copy_simd(state->scratch_vector, state->vector, size);
    
    for (i = 0; i < size; i++) {
        if ((i & c_bit) != 0 && (i & t_bit) == 0) {
            long index0 = i;
            long index1 = i | t_bit;

            struct t_complex v0 = state->vector[index0];
            struct t_complex v1 = state->vector[index1];

            state->scratch_vector[index0] = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
            state->scratch_vector[index1] = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
        } else {
            state->scratch_vector[i] = state->vector[i];
        }
    }
    
  #elif defined(QCS_MULTI_THREAD)
    extern thread_pool_t *pool;
    
    memcpy(state->scratch_vector, state->vector, size * sizeof(struct t_complex));

    int effective_threads = (pool->num_threads > 4) ? 4 : pool->num_threads;
    long work_per_thread = (size + effective_threads - 1) / effective_threads;
    int k;

    for (k = 0; k < effective_threads; k++) {
        long start = k * work_per_thread;
        long end = (k + 1) * work_per_thread;
        if (end > size) end = size;
        
        if (start >= end) break;

        struct t_thread_args *args = malloc(sizeof(struct t_thread_args));
        if (!args) exit(EXIT_FAILURE);

        args->start = start;
        args->end = end;
        args->state = state;
        args->gate = gate;
        args->control_qubit = control_qubit;
        args->target_qubit = target_qubit;

        thread_pool_add_task(pool, q_apply_2q_gate_worker, args);
    }
    thread_pool_wait(pool);
    
  #else
    memcpy(state->scratch_vector, state->vector, size * sizeof(struct t_complex));

    for (i = 0; i < size; i++) {
        if ((i & c_bit) != 0 && (i & t_bit) == 0) {
            long index0 = i;
            long index1 = i | t_bit;

            struct t_complex v0 = state->vector[index0];
            struct t_complex v1 = state->vector[index1];

            state->scratch_vector[index0] = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
            state->scratch_vector[index1] = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
        } else {
            state->scratch_vector[i] = state->vector[i];
        }
    }
  #endif

  struct t_complex *temp = state->vector;
  state->vector = state->scratch_vector;
  state->scratch_vector = temp;
}

/**
 * Apply phase flip to a specific quantum state
 * @param state Quantum state vector
 * @param index Index of state to flip
 */
void q_apply_phase_flip(struct t_q_state *state, int index) {
  if (state == NULL || index < 0 || index >= state->size) {
    fprintf(stderr, "Error: Invalid state or index for phase flip.\n");
    return;
  }

  struct t_complex *temp = state->vector;
  state->vector = state->scratch_vector;
  state->scratch_vector = temp;

  state->vector[index].number_real = -state->scratch_vector[index].number_real;
  state->vector[index].number_imaginary = -state->scratch_vector[index].number_imaginary;
}

/**
 * Apply diffusion operator for Grover's algorithm
 * @param state Quantum state vector
 */
void q_apply_diffusion(struct t_q_state *state) {
  if (state == NULL) {
    fprintf(stderr, "Error: Invalid state for diffusion.\n");
    return;
  }

  long size = state->size;
  long i;
  struct t_complex mean = c_zero();
  double mean_magnitude;

  for (i = 0; i < size; i++) {
    mean = c_add(mean, state->vector[i]);
  }
  mean_magnitude = c_magnitude(mean);

  if (mean_magnitude > 1e-10) {
    mean.number_real /= mean_magnitude;
    mean.number_imaginary /= mean_magnitude;
  }

  struct t_complex two_mean = {2.0 * mean.number_real, 2.0 * mean.number_imaginary};
  
  struct t_complex *temp = state->vector;
  state->vector = state->scratch_vector;
  state->scratch_vector = temp;

  for (i = 0; i < size; i++) {
    state->vector[i].number_real = 
        two_mean.number_real - state->scratch_vector[i].number_real;
    state->vector[i].number_imaginary = 
        two_mean.number_imaginary - state->scratch_vector[i].number_imaginary;
  }
}

/**
 * Create identity gate matrix
 * @return Identity gate matrix
 */
struct t_q_matrix *q_gate_I(void) {
  struct t_q_matrix *i = q_matrix_init(2, 2);
  if (!i)
    return NULL;
  i->data[0] = c_one();
  i->data[3] = c_one();
  return i;
}

/**
 * Create X (Pauli-X) gate matrix
 * @return X gate matrix
 */
struct t_q_matrix *q_gate_X(void) {
  struct t_q_matrix *X = q_matrix_init(2, 2);
  if (!X)
    return NULL;
  X->data[1] = c_one();
  X->data[2] = c_one();
  return X;
}

/**
 * Create Hadamard gate matrix
 * @return Hadamard gate matrix
 */
struct t_q_matrix *q_gate_H(void) {
  double root2_inv = 1.0 / sqrt(2.0);
  struct t_complex factor = c_from_real(root2_inv);
  struct t_q_matrix *H = q_matrix_init(2, 2);
  if (!H)
    return NULL;
  H->data[0] = factor;
  H->data[1] = factor;
  H->data[2] = factor;
  H->data[3] = c_from_real(-root2_inv);
  return H;
}

struct t_q_matrix *q_gate_CP(double angle) {
  struct t_q_matrix *CP = q_matrix_init(2, 2);
  if (!CP)
    return NULL;

  CP->data[0] = c_one();
  CP->data[3].number_real = cos(angle);
  CP->data[3].number_imaginary = sin(angle);
  return CP;
}

/**
 * Create Y (Pauli-Y) gate matrix
 * @return Y gate matrix
 */
struct t_q_matrix *q_gate_Y(void) {
  struct t_q_matrix *Y = q_matrix_init(2, 2);
  if (!Y)
    return NULL;
  Y->data[1].number_imaginary = -1.0;
  Y->data[2].number_imaginary = 1.0;
  return Y;
}

/**
 * Create Z (Pauli-Z) gate matrix
 * @return Z gate matrix
 */
struct t_q_matrix *q_gate_Z(void) {
  struct t_q_matrix *Z = q_matrix_init(2, 2);
  if (!Z)
    return NULL;
  Z->data[0] = c_one();
  Z->data[3] = c_from_real(-1.0);
  return Z;
}

struct t_q_matrix *q_gate_P(double angle) {
  struct t_q_matrix *P = q_matrix_init(2, 2);
  if (!P)
    return NULL;
  P->data[0] = c_one();
  P->data[3].number_real = cos(angle);
  P->data[3].number_imaginary = sin(angle);
  return P;
}

struct t_q_matrix *q_gate_RX(double angle) {
  struct t_q_matrix *RX = q_matrix_init(2, 2);
  double cos_half = cos(angle / 2.0);
  double sin_half = sin(angle / 2.0);
  if (!RX)
    return NULL;

  RX->data[0].number_real = cos_half;
  RX->data[1].number_imaginary = -sin_half;
  RX->data[2].number_imaginary = -sin_half;
  RX->data[3].number_real = cos_half;

  return RX;
}

struct t_q_matrix *q_gate_RY(double angle) {
  struct t_q_matrix *RY = q_matrix_init(2, 2);
  double cos_half = cos(angle / 2.0);
  double sin_half = sin(angle / 2.0);
  if (!RY)
    return NULL;

  RY->data[0].number_real = cos_half;
  RY->data[1].number_real = -sin_half;
  RY->data[2].number_real = sin_half;
  RY->data[3].number_real = cos_half;

  return RY;
}

struct t_q_matrix *q_gate_RZ(double angle) {
  struct t_q_matrix *RZ = q_matrix_init(2, 2);
  double cos_half = cos(angle / 2.0);
  double sin_half = sin(angle / 2.0);
  if (!RZ)
    return NULL;

  RZ->data[0].number_real = cos_half;
  RZ->data[0].number_imaginary = -sin_half;
  RZ->data[3].number_real = cos_half;
  RZ->data[3].number_imaginary = sin_half;

  return RZ;
}

#ifdef QCS_MULTI_THREAD
static void q_apply_1q_gate_worker(void *arg) {
  struct t_thread_args *args = (struct t_thread_args *)arg;
  struct t_q_state *state = args->state;
  const struct t_q_matrix *gate = args->gate;
  int target_qubit = args->target_qubit;
  long start = args->start;
  long end = args->end;
  long step = 1L << target_qubit;
  long block_size = 1L << (target_qubit + 1);
  long i, j;

  for (i = start; i < end; i += block_size) {
    for (j = i; j < i + step && j < end; j++) {
      long index0 = j;
      long index1 = j + step;
      struct t_complex v0 = state->vector[index0];
      struct t_complex v1 = state->vector[index1];

      state->scratch_vector[index0] = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
      state->scratch_vector[index1] = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
    }
  }
  free(args);
}

static void q_apply_2q_gate_worker(void *arg) {
  struct t_thread_args *args = (struct t_thread_args *)arg;
  struct t_q_state *state = args->state;
  const struct t_q_matrix *gate = args->gate;
  int control_qubit = args->control_qubit;
  int target_qubit = args->target_qubit;
  long start = args->start;
  long end = args->end;
  long c_bit = 1L << control_qubit;
  long t_bit = 1L << target_qubit;
  long i;

  for (i = start; i < end; i++) {
    if ((i & c_bit) != 0 && (i & t_bit) == 0) {
      long index0 = i;
      long index1 = i | t_bit;

      struct t_complex v0 = state->vector[index0];
      struct t_complex v1 = state->vector[index1];

      state->scratch_vector[index0] = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
      state->scratch_vector[index1] = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
    } else {
      state->scratch_vector[i] = state->vector[i];
    }
  }
  free(args);
}
#endif
/* ------------------------------------------------------------------------- */
/* gpu_complex.c implementation (GPU)                                */
/* ------------------------------------------------------------------------- */

#ifdef QCS_GPU_OPENCL
#ifdef QCS_GPU_OPENCL
#include <CL/cl.h>
#endif

static cl_context gpu_context = NULL;
static cl_command_queue gpu_queue = NULL;
static cl_device_id gpu_device = NULL;
static cl_program gpu_program = NULL;
static cl_kernel add_kernel = NULL;
static cl_kernel mul_kernel = NULL;
static cl_kernel copy_kernel = NULL;
static cl_kernel norm_kernel = NULL;
static cl_kernel gate_1q_kernel = NULL;
static cl_kernel gate_2q_kernel = NULL;

static cl_mem persistent_state_buffer = NULL;
static cl_mem persistent_scratch_buffer = NULL;
static long persistent_buffer_size = 0;
static int gpu_initialized = 0;
static const char* kernel_source = 
"__kernel void complex_add(__global float2* a, __global float2* b, __global float2* result, int count) {\n"
"    int i = get_global_id(0);\n"
"    if (i < count) {\n"
"        result[i].x = a[i].x + b[i].x;\n"
"        result[i].y = a[i].y + b[i].y;\n"
"    }\n"
"}\n"
"\n"
"__kernel void complex_mul(__global float2* a, __global float2* b, __global float2* result, int count) {\n"
"    int i = get_global_id(0);\n"
"    if (i < count) {\n"
"        float real = a[i].x * b[i].x - a[i].y * b[i].y;\n"
"        float imag = a[i].x * b[i].y + a[i].y * b[i].x;\n"
"        result[i].x = real;\n"
"        result[i].y = imag;\n"
"    }\n"
"}\n"
"\n"
"__kernel void complex_copy(__global float2* src, __global float2* dest, int count) {\n"
"    int i = get_global_id(0);\n"
"    if (i < count) {\n"
"        dest[i] = src[i];\n"
"    }\n"
"}\n"
"\n"
"__kernel void complex_norm_sum(__global float2* a, __global float* result, int count) {\n"
"    int i = get_global_id(0);\n"
"    if (i < count) {\n"
"        result[i] = a[i].x * a[i].x + a[i].y * a[i].y;\n"
"    }\n"
"}\n"
"\n"
"/* Quantum gate kernels */\n"
"__kernel void apply_1q_gate(__global float2* state, __global float2* scratch, \n"
"                           __global float2* gate_matrix, int target_qubit, int size) {\n"
"    int i = get_global_id(0);\n"
"    int step = 1 << target_qubit;\n"
"    int block_size = 1 << (target_qubit + 1);\n"
"    \n"
"    if (i < size) {\n"
"        int block_start = (i / block_size) * block_size;\n"
"        int j = block_start + (i % step);\n"
"        \n"
"        if (j < size) {\n"
"            int index0 = j;\n"
"            int index1 = j + step;\n"
"            \n"
"            if (index1 < size) {\n"
"                float2 v0 = state[index0];\n"
"                float2 v1 = state[index1];\n"
"                \n"
"                float2 gate0 = gate_matrix[0];\n"
"                float2 gate1 = gate_matrix[1];\n"
"                float2 gate2 = gate_matrix[2];\n"
"                float2 gate3 = gate_matrix[3];\n"
"                \n"
"                /* Apply gate matrix multiplication */\n"
"                float2 temp0, temp1;\n"
"                temp0.x = gate0.x * v0.x - gate0.y * v0.y + gate1.x * v1.x - gate1.y * v1.y;\n"
"                temp0.y = gate0.x * v0.y + gate0.y * v0.x + gate1.x * v1.y + gate1.y * v1.x;\n"
"                temp1.x = gate2.x * v0.x - gate2.y * v0.y + gate3.x * v1.x - gate3.y * v1.y;\n"
"                temp1.y = gate2.x * v0.y + gate2.y * v0.x + gate3.x * v1.y + gate3.y * v1.x;\n"
"                \n"
"                scratch[index0] = temp0;\n"
"                scratch[index1] = temp1;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"__kernel void apply_2q_gate(__global float2* state, __global float2* scratch, \n"
"                           __global float2* gate_matrix, int control_qubit, int target_qubit, int size) {\n"
"    int i = get_global_id(0);\n"
"    int c_bit = 1 << control_qubit;\n"
"    int t_bit = 1 << target_qubit;\n"
"    \n"
"    if (i < size && (i & c_bit) != 0) {\n"
"        int index00 = i & ~t_bit;\n"
"        int index01 = i | t_bit;\n"
"        int index10 = (i & ~t_bit) | c_bit;\n"
"        int index11 = i;\n"
"        \n"
"        if (index00 < size && index01 < size && index10 < size && index11 < size) {\n"
"            float2 v00 = state[index00];\n"
"            float2 v01 = state[index01];\n"
"            float2 v10 = state[index10];\n"
"            float2 v11 = state[index11];\n"
"            \n"
"            /* Apply 4x4 gate matrix */\n"
"            float2 result00, result01, result10, result11;\n"
"            \n"
"            result00.x = gate_matrix[0].x * v00.x - gate_matrix[0].y * v00.y +\n"
"                        gate_matrix[1].x * v01.x - gate_matrix[1].y * v01.y +\n"
"                        gate_matrix[2].x * v10.x - gate_matrix[2].y * v10.y +\n"
"                        gate_matrix[3].x * v11.x - gate_matrix[3].y * v11.y;\n"
"            result00.y = gate_matrix[0].x * v00.y + gate_matrix[0].y * v00.x +\n"
"                        gate_matrix[1].x * v01.y + gate_matrix[1].y * v01.x +\n"
"                        gate_matrix[2].x * v10.y + gate_matrix[2].y * v10.x +\n"
"                        gate_matrix[3].x * v11.y + gate_matrix[3].y * v11.x;\n"
"            \n"
"            result01.x = gate_matrix[4].x * v00.x - gate_matrix[4].y * v00.y +\n"
"                        gate_matrix[5].x * v01.x - gate_matrix[5].y * v01.y +\n"
"                        gate_matrix[6].x * v10.x - gate_matrix[6].y * v10.y +\n"
"                        gate_matrix[7].x * v11.x - gate_matrix[7].y * v11.y;\n"
"            result01.y = gate_matrix[4].x * v00.y + gate_matrix[4].y * v00.x +\n"
"                        gate_matrix[5].x * v01.y + gate_matrix[5].y * v01.x +\n"
"                        gate_matrix[6].x * v10.y + gate_matrix[6].y * v10.x +\n"
"                        gate_matrix[7].x * v11.y + gate_matrix[7].y * v11.x;\n"
"            \n"
"            result10.x = gate_matrix[8].x * v00.x - gate_matrix[8].y * v00.y +\n"
"                        gate_matrix[9].x * v01.x - gate_matrix[9].y * v01.y +\n"
"                        gate_matrix[10].x * v10.x - gate_matrix[10].y * v10.y +\n"
"                        gate_matrix[11].x * v11.x - gate_matrix[11].y * v11.y;\n"
"            result10.y = gate_matrix[8].x * v00.y + gate_matrix[8].y * v00.x +\n"
"                        gate_matrix[9].x * v01.y + gate_matrix[9].y * v01.x +\n"
"                        gate_matrix[10].x * v10.y + gate_matrix[10].y * v10.x +\n"
"                        gate_matrix[11].x * v11.y + gate_matrix[11].y * v11.x;\n"
"            \n"
"            result11.x = gate_matrix[12].x * v00.x - gate_matrix[12].y * v00.y +\n"
"                        gate_matrix[13].x * v01.x - gate_matrix[13].y * v01.y +\n"
"                        gate_matrix[14].x * v10.x - gate_matrix[14].y * v10.y +\n"
"                        gate_matrix[15].x * v11.x - gate_matrix[15].y * v11.y;\n"
"            result11.y = gate_matrix[12].x * v00.y + gate_matrix[12].y * v00.x +\n"
"                        gate_matrix[13].x * v01.y + gate_matrix[13].y * v01.x +\n"
"                        gate_matrix[14].x * v10.y + gate_matrix[14].y * v10.x +\n"
"                        gate_matrix[15].x * v11.y + gate_matrix[15].y * v11.x;\n"
"            \n"
"            scratch[index00] = result00;\n"
"            scratch[index01] = result01;\n"
"            scratch[index10] = result10;\n"
"            scratch[index11] = result11;\n"
"        }\n"
"    }\n"
"}\n";

/**
 * Initialize OpenCL GPU context and create kernels for quantum operations
 * @return 1 on success, 0 on failure
 */
static int init_gpu_context(void) {
    cl_int err;
    cl_platform_id platforms[10];
    cl_uint num_platforms;
    int i;
    
    err = clGetPlatformIDs(10, platforms, &num_platforms);
    if (err != CL_SUCCESS || num_platforms == 0) {
        return 0;
    }
    
    for (i = 0; i < num_platforms; i++) {
        err = clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_GPU, 1, &gpu_device, NULL);
        if (err == CL_SUCCESS) {
            break;
        }
    }
    
    if (err != CL_SUCCESS) {
        return 0;
    }
    
    gpu_context = clCreateContext(NULL, 1, &gpu_device, NULL, NULL, &err);
    if (err != CL_SUCCESS) {
        return 0;
    }
    
    gpu_queue = clCreateCommandQueue(gpu_context, gpu_device, 0, &err);
    if (err != CL_SUCCESS) {
        return 0;
    }
    
    gpu_program = clCreateProgramWithSource(gpu_context, 1, &kernel_source, NULL, &err);
    if (err != CL_SUCCESS) {
        return 0;
    }
    
    err = clBuildProgram(gpu_program, 1, &gpu_device, NULL, NULL, NULL);
    if (err != CL_SUCCESS) {
        return 0;
    }
    add_kernel = clCreateKernel(gpu_program, "complex_add", &err);
    if (err != CL_SUCCESS) return 0;
    
    mul_kernel = clCreateKernel(gpu_program, "complex_mul", &err);
    if (err != CL_SUCCESS) return 0;
    
    copy_kernel = clCreateKernel(gpu_program, "complex_copy", &err);
    if (err != CL_SUCCESS) return 0;
    
    norm_kernel = clCreateKernel(gpu_program, "complex_norm_sum", &err);
    if (err != CL_SUCCESS) return 0;
    
    gate_1q_kernel = clCreateKernel(gpu_program, "apply_1q_gate", &err);
    if (err != CL_SUCCESS) return 0;
    
    gate_2q_kernel = clCreateKernel(gpu_program, "apply_2q_gate", &err);
    if (err != CL_SUCCESS) return 0;
    
    return 1;
}

/**
 * Cleanup OpenCL resources and release all GPU memory
 */
static void cleanup_gpu_context(void) {
    if (persistent_scratch_buffer) clReleaseMemObject(persistent_scratch_buffer);
    if (persistent_state_buffer) clReleaseMemObject(persistent_state_buffer);
    if (gate_2q_kernel) clReleaseKernel(gate_2q_kernel);
    if (gate_1q_kernel) clReleaseKernel(gate_1q_kernel);
    if (norm_kernel) clReleaseKernel(norm_kernel);
    if (copy_kernel) clReleaseKernel(copy_kernel);
    if (mul_kernel) clReleaseKernel(mul_kernel);
    if (add_kernel) clReleaseKernel(add_kernel);
    if (gpu_program) clReleaseProgram(gpu_program);
    if (gpu_queue) clReleaseCommandQueue(gpu_queue);
    if (gpu_context) clReleaseContext(gpu_context);
    
    persistent_state_buffer = NULL;
    persistent_scratch_buffer = NULL;
    persistent_buffer_size = 0;
    gpu_initialized = 0;
}

/**
 * Initialize persistent GPU memory buffers for quantum state operations
 * @param size Size of the quantum state vector
 * @return 1 on success, 0 on failure
 */
static int init_persistent_gpu_memory(long size) {
    cl_int err;
    
    if (persistent_buffer_size >= size && persistent_state_buffer != NULL) {
        return 1;
    }
    
    if (persistent_state_buffer) {
        clReleaseMemObject(persistent_state_buffer);
        persistent_state_buffer = NULL;
    }
    if (persistent_scratch_buffer) {
        clReleaseMemObject(persistent_scratch_buffer);
        persistent_scratch_buffer = NULL;
    }
    persistent_state_buffer = clCreateBuffer(gpu_context, CL_MEM_READ_WRITE, 
                                           size * sizeof(struct t_complex), NULL, &err);
    if (err != CL_SUCCESS) return 0;
    
    persistent_scratch_buffer = clCreateBuffer(gpu_context, CL_MEM_READ_WRITE, 
                                             size * sizeof(struct t_complex), NULL, &err);
    if (err != CL_SUCCESS) {
        clReleaseMemObject(persistent_state_buffer);
        persistent_state_buffer = NULL;
        return 0;
    }
    
    persistent_buffer_size = size;
    return 1;
}

/**
 * Upload quantum state vector to GPU memory
 * @param state Quantum state to upload
 * @return 1 on success, 0 on failure
 */
static int upload_state_to_gpu(struct t_q_state *state) {
    cl_int err;
    
    if (!init_persistent_gpu_memory(state->size)) {
        return 0;
    }
    
    err = clEnqueueWriteBuffer(gpu_queue, persistent_state_buffer, CL_TRUE, 0,
                              state->size * sizeof(struct t_complex), state->vector, 0, NULL, NULL);
    return (err == CL_SUCCESS);
}

/**
 * Download quantum state vector from GPU memory
 * @param state Quantum state to download to
 * @return 1 on success, 0 on failure
 */
static int download_state_from_gpu(struct t_q_state *state) {
    cl_int err;
    
    if (persistent_state_buffer == NULL) {
        return 0;
    }
    
    err = clEnqueueReadBuffer(gpu_queue, persistent_state_buffer, CL_TRUE, 0,
                             state->size * sizeof(struct t_complex), state->vector, 0, NULL, NULL);
    return (err == CL_SUCCESS);
}

/**
 * GPU-accelerated complex number addition using OpenCL
 * @param result Output array for results
 * @param a First input array
 * @param b Second input array
 * @param count Number of elements to process
 */
void c_add_gpu_real(struct t_complex *result, const struct t_complex *a, 
                    const struct t_complex *b, long count) {
    
    static int initialized = 0;
    if (!initialized) {
        if (!init_gpu_context()) {
            c_add_simd(result, a, b, count);
            return;
        }
        initialized = 1;
    }
    
    cl_int err;
    cl_mem a_buf, b_buf, result_buf;
    size_t global_size = count;
    size_t local_size = 64;
    
    /* Create buffers */
    a_buf = clCreateBuffer(gpu_context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, 
                          count * sizeof(float) * 2, (void*)a, &err);
    b_buf = clCreateBuffer(gpu_context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, 
                          count * sizeof(float) * 2, (void*)b, &err);
    result_buf = clCreateBuffer(gpu_context, CL_MEM_WRITE_ONLY, 
                               count * sizeof(float) * 2, NULL, &err);
    
    if (err != CL_SUCCESS) {
        c_add_simd(result, a, b, count);
        return;
    }
    
    clSetKernelArg(add_kernel, 0, sizeof(cl_mem), &a_buf);
    clSetKernelArg(add_kernel, 1, sizeof(cl_mem), &b_buf);
    clSetKernelArg(add_kernel, 2, sizeof(cl_mem), &result_buf);
    clSetKernelArg(add_kernel, 3, sizeof(int), &count);
    
    err = clEnqueueNDRangeKernel(gpu_queue, add_kernel, 1, NULL, &global_size, &local_size, 0, NULL, NULL);
    if (err != CL_SUCCESS) {
        c_add_simd(result, a, b, count);
        return;
    }
    
    clEnqueueReadBuffer(gpu_queue, result_buf, CL_TRUE, 0, count * sizeof(float) * 2, result, 0, NULL, NULL);
    
    clReleaseMemObject(a_buf);
    clReleaseMemObject(b_buf);
    clReleaseMemObject(result_buf);
}

void c_mul_gpu_real(struct t_complex *result, const struct t_complex *a, 
                    const struct t_complex *b, long count) {
    
    static int initialized = 0;
    if (!initialized) {
        if (!init_gpu_context()) {
            c_mul_simd(result, a, b, count);
            return;
        }
        initialized = 1;
    }
    
    cl_int err;
    cl_mem a_buf, b_buf, result_buf;
    size_t global_size = count;
    size_t local_size = 64;
    
    a_buf = clCreateBuffer(gpu_context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, 
                          count * sizeof(float) * 2, (void*)a, &err);
    b_buf = clCreateBuffer(gpu_context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, 
                          count * sizeof(float) * 2, (void*)b, &err);
    result_buf = clCreateBuffer(gpu_context, CL_MEM_WRITE_ONLY, 
                               count * sizeof(float) * 2, NULL, &err);
    
    if (err != CL_SUCCESS) {
        c_mul_simd(result, a, b, count);
        return;
    }
    
    clSetKernelArg(mul_kernel, 0, sizeof(cl_mem), &a_buf);
    clSetKernelArg(mul_kernel, 1, sizeof(cl_mem), &b_buf);
    clSetKernelArg(mul_kernel, 2, sizeof(cl_mem), &result_buf);
    clSetKernelArg(mul_kernel, 3, sizeof(int), &count);
    
    err = clEnqueueNDRangeKernel(gpu_queue, mul_kernel, 1, NULL, &global_size, &local_size, 0, NULL, NULL);
    if (err != CL_SUCCESS) {
        c_mul_simd(result, a, b, count);
        return;
    }
    
    clEnqueueReadBuffer(gpu_queue, result_buf, CL_TRUE, 0, count * sizeof(float) * 2, result, 0, NULL, NULL);
    
    clReleaseMemObject(a_buf);
    clReleaseMemObject(b_buf);
    clReleaseMemObject(result_buf);
}

void c_copy_gpu_real(struct t_complex *dest, const struct t_complex *src, long count) {
    
    static int initialized = 0;
    if (!initialized) {
        if (!init_gpu_context()) {
            c_copy_simd(dest, src, count);
            return;
        }
        initialized = 1;
    }
    
    cl_int err;
    cl_mem src_buf, dest_buf;
    size_t global_size = count;
    size_t local_size = 64;
    
    src_buf = clCreateBuffer(gpu_context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, 
                            count * sizeof(float) * 2, (void*)src, &err);
    dest_buf = clCreateBuffer(gpu_context, CL_MEM_WRITE_ONLY, 
                             count * sizeof(float) * 2, NULL, &err);
    
    if (err != CL_SUCCESS) {
        c_copy_simd(dest, src, count);
        return;
    }
    
    clSetKernelArg(copy_kernel, 0, sizeof(cl_mem), &src_buf);
    clSetKernelArg(copy_kernel, 1, sizeof(cl_mem), &dest_buf);
    clSetKernelArg(copy_kernel, 2, sizeof(int), &count);
    
    err = clEnqueueNDRangeKernel(gpu_queue, copy_kernel, 1, NULL, &global_size, &local_size, 0, NULL, NULL);
    if (err != CL_SUCCESS) {
        c_copy_simd(dest, src, count);
        return;
    }
    
    clEnqueueReadBuffer(gpu_queue, dest_buf, CL_TRUE, 0, count * sizeof(float) * 2, dest, 0, NULL, NULL);
    
    clReleaseMemObject(src_buf);
    clReleaseMemObject(dest_buf);
}

double c_norm_sq_sum_gpu_real(const struct t_complex *a, long count) {
    
    static int initialized = 0;
    if (!initialized) {
        if (!init_gpu_context()) {
            return c_norm_sq_sum_simd(a, count);
        }
        initialized = 1;
    }
    
    cl_int err;
    cl_mem a_buf, result_buf;
    float *temp_result;
    double sum = 0.0;
    size_t global_size = count;
    size_t local_size = 64;
    long i;
    
    temp_result = malloc(count * sizeof(float));
    if (!temp_result) {
        return c_norm_sq_sum_simd(a, count);
    }
    
    a_buf = clCreateBuffer(gpu_context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, 
                          count * sizeof(float) * 2, (void*)a, &err);
    result_buf = clCreateBuffer(gpu_context, CL_MEM_WRITE_ONLY, 
                               count * sizeof(float), NULL, &err);
    
    if (err != CL_SUCCESS) {
        free(temp_result);
        return c_norm_sq_sum_simd(a, count);
    }
    
    clSetKernelArg(norm_kernel, 0, sizeof(cl_mem), &a_buf);
    clSetKernelArg(norm_kernel, 1, sizeof(cl_mem), &result_buf);
    clSetKernelArg(norm_kernel, 2, sizeof(int), &count);
    
    err = clEnqueueNDRangeKernel(gpu_queue, norm_kernel, 1, NULL, &global_size, &local_size, 0, NULL, NULL);
    if (err != CL_SUCCESS) {
        free(temp_result);
        return c_norm_sq_sum_simd(a, count);
    }
    
    clEnqueueReadBuffer(gpu_queue, result_buf, CL_TRUE, 0, count * sizeof(float), temp_result, 0, NULL, NULL);
    
    for (i = 0; i < count; i++) {
        sum += temp_result[i];
    }
    
    clReleaseMemObject(a_buf);
    clReleaseMemObject(result_buf);
    free(temp_result);
    
    return sum;
}

/**
 * GPU-accelerated 1-qubit quantum gate application using persistent memory
 * @param state Quantum state vector
 * @param gate 2x2 gate matrix
 * @param target_qubit Target qubit index
 */
void q_apply_1q_gate_gpu(struct t_q_state *state, const struct t_q_matrix *gate, int target_qubit) {
    long size = state->size;
    cl_int err;
    cl_mem gate_buf;
    size_t global_size = size;
    size_t local_size = 256; 
    
    if (state == NULL || gate == NULL || target_qubit < 0 || target_qubit >= state->qubits_num) {
        fprintf(stderr, "Error: Invalid arguments for 1-qubit gate application.\n");
        return;
    }
    
    if (!gpu_initialized) {
        if (!init_gpu_context()) {
            long step = 1L << target_qubit;
            long block_size = 1L << (target_qubit + 1);
            long i, j;
            
            for (i = 0; i < size; i += block_size) {
                for (j = i; j < i + step; j++) {
                    long index0 = j;
                    long index1 = j + step;
                    
                    struct t_complex v0 = state->vector[index0];
                    struct t_complex v1 = state->vector[index1];
                    
                    struct t_complex temp0, temp1;
                    temp0 = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
                    temp1 = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
                    
                    state->scratch_vector[index0] = temp0;
                    state->scratch_vector[index1] = temp1;
                }
            }
            
            for (i = 0; i < size; i++) {
                state->vector[i] = state->scratch_vector[i];
            }
            return;
        }
        gpu_initialized = 1;
    }
    
    if (!init_persistent_gpu_memory(size)) {
        long step = 1L << target_qubit;
        long block_size = 1L << (target_qubit + 1);
        long i, j;
        
        for (i = 0; i < size; i += block_size) {
            for (j = i; j < i + step; j++) {
                long index0 = j;
                long index1 = j + step;
                
                struct t_complex v0 = state->vector[index0];
                struct t_complex v1 = state->vector[index1];
                
                struct t_complex temp0, temp1;
                temp0 = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
                temp1 = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
                
                state->scratch_vector[index0] = temp0;
                state->scratch_vector[index1] = temp1;
            }
        }
        
        for (i = 0; i < size; i++) {
            state->vector[i] = state->scratch_vector[i];
        }
        return;
    }
    
    static long last_uploaded_size = 0;
    if (last_uploaded_size != size) {
        if (!upload_state_to_gpu(state)) {
            long step = 1L << target_qubit;
            long block_size = 1L << (target_qubit + 1);
            long i, j;
            
            for (i = 0; i < size; i += block_size) {
                for (j = i; j < i + step; j++) {
                    long index0 = j;
                    long index1 = j + step;
                    
                    struct t_complex v0 = state->vector[index0];
                    struct t_complex v1 = state->vector[index1];
                    
                    struct t_complex temp0, temp1;
                    temp0 = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
                    temp1 = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
                    
                    state->scratch_vector[index0] = temp0;
                    state->scratch_vector[index1] = temp1;
                }
            }
            
            for (i = 0; i < size; i++) {
                state->vector[i] = state->scratch_vector[i];
            }
            return;
        }
        last_uploaded_size = size;
    }
    
    gate_buf = clCreateBuffer(gpu_context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, 
                             4 * sizeof(struct t_complex), gate->data, &err);
    if (err != CL_SUCCESS) {
        long step = 1L << target_qubit;
        long block_size = 1L << (target_qubit + 1);
        long i, j;
        
        for (i = 0; i < size; i += block_size) {
            for (j = i; j < i + step; j++) {
                long index0 = j;
                long index1 = j + step;
                
                struct t_complex v0 = state->vector[index0];
                struct t_complex v1 = state->vector[index1];
                
                struct t_complex temp0, temp1;
                temp0 = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
                temp1 = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
                
                state->scratch_vector[index0] = temp0;
                state->scratch_vector[index1] = temp1;
            }
        }
        
        for (i = 0; i < size; i++) {
            state->vector[i] = state->scratch_vector[i];
        }
        return;
    }
    
    clSetKernelArg(gate_1q_kernel, 0, sizeof(cl_mem), &persistent_state_buffer);
    clSetKernelArg(gate_1q_kernel, 1, sizeof(cl_mem), &persistent_scratch_buffer);
    clSetKernelArg(gate_1q_kernel, 2, sizeof(cl_mem), &gate_buf);
    clSetKernelArg(gate_1q_kernel, 3, sizeof(int), &target_qubit);
    clSetKernelArg(gate_1q_kernel, 4, sizeof(int), &size);
    
    err = clEnqueueNDRangeKernel(gpu_queue, gate_1q_kernel, 1, NULL, &global_size, &local_size, 0, NULL, NULL);
    if (err != CL_SUCCESS) {
        clReleaseMemObject(gate_buf);
        long step = 1L << target_qubit;
        long block_size = 1L << (target_qubit + 1);
        long i, j;
        
        for (i = 0; i < size; i += block_size) {
            for (j = i; j < i + step; j++) {
                long index0 = j;
                long index1 = j + step;
                
                struct t_complex v0 = state->vector[index0];
                struct t_complex v1 = state->vector[index1];
                
                struct t_complex temp0, temp1;
                temp0 = c_add(c_mul(gate->data[0], v0), c_mul(gate->data[1], v1));
                temp1 = c_add(c_mul(gate->data[2], v0), c_mul(gate->data[3], v1));
                
                state->scratch_vector[index0] = temp0;
                state->scratch_vector[index1] = temp1;
            }
        }
        
        for (i = 0; i < size; i++) {
            state->vector[i] = state->scratch_vector[i];
        }
        return;
    }
    
    cl_mem temp = persistent_state_buffer;
    persistent_state_buffer = persistent_scratch_buffer;
    persistent_scratch_buffer = temp;
    
    clReleaseMemObject(gate_buf);
}

/**
 * GPU-accelerated 2-qubit quantum gate application using persistent memory
 * @param state Quantum state vector
 * @param gate 4x4 gate matrix
 * @param control_qubit Control qubit index
 * @param target_qubit Target qubit index
 */
void q_apply_2q_gate_gpu(struct t_q_state *state, const struct t_q_matrix *gate, 
                         int control_qubit, int target_qubit) {
    long size = state->size;
    cl_int err;
    cl_mem gate_buf;
    size_t global_size = size;
    size_t local_size = 256;
    
    if (state == NULL || gate == NULL || control_qubit < 0 || target_qubit < 0 ||
        control_qubit >= state->qubits_num || target_qubit >= state->qubits_num) {
        fprintf(stderr, "Error: Invalid arguments for 2-qubit gate application.\n");
        return;
    }
    
    if (!gpu_initialized) {
        if (!init_gpu_context()) {
            long c_bit = 1L << control_qubit;
            long t_bit = 1L << target_qubit;
            long i;
            
            for (i = 0; i < size; i++) {
                if ((i & c_bit) != 0) {  
                    long index00 = i & ~t_bit;
                    long index01 = i | t_bit;
                    long index10 = (i & ~t_bit) | c_bit;
                    long index11 = i;
                    
                    if (index00 < size && index01 < size && index10 < size && index11 < size) {
                        struct t_complex v00 = state->vector[index00];
                        struct t_complex v01 = state->vector[index01];
                        struct t_complex v10 = state->vector[index10];
                        struct t_complex v11 = state->vector[index11];
                        
                        state->scratch_vector[index00] = c_add(c_add(c_mul(gate->data[0], v00), c_mul(gate->data[1], v01)), 
                                                              c_add(c_mul(gate->data[2], v10), c_mul(gate->data[3], v11)));
                        state->scratch_vector[index01] = c_add(c_add(c_mul(gate->data[4], v00), c_mul(gate->data[5], v01)), 
                                                              c_add(c_mul(gate->data[6], v10), c_mul(gate->data[7], v11)));
                        state->scratch_vector[index10] = c_add(c_add(c_mul(gate->data[8], v00), c_mul(gate->data[9], v01)), 
                                                              c_add(c_mul(gate->data[10], v10), c_mul(gate->data[11], v11)));
                        state->scratch_vector[index11] = c_add(c_add(c_mul(gate->data[12], v00), c_mul(gate->data[13], v01)), 
                                                              c_add(c_mul(gate->data[14], v10), c_mul(gate->data[15], v11)));
                    }
                }
            }
            
            for (i = 0; i < size; i++) {
                state->vector[i] = state->scratch_vector[i];
            }
            return;
        }
        gpu_initialized = 1;
    }
    
    if (!init_persistent_gpu_memory(size)) {
        long c_bit = 1L << control_qubit;
        long t_bit = 1L << target_qubit;
        long i;
        
        for (i = 0; i < size; i++) {
            if ((i & c_bit) != 0) { 
                long index00 = i & ~t_bit;
                long index01 = i | t_bit;
                long index10 = (i & ~t_bit) | c_bit;
                long index11 = i;
                
                if (index00 < size && index01 < size && index10 < size && index11 < size) {
                    struct t_complex v00 = state->vector[index00];
                    struct t_complex v01 = state->vector[index01];
                    struct t_complex v10 = state->vector[index10];
                    struct t_complex v11 = state->vector[index11];
                    
                    state->scratch_vector[index00] = c_add(c_add(c_mul(gate->data[0], v00), c_mul(gate->data[1], v01)), 
                                                          c_add(c_mul(gate->data[2], v10), c_mul(gate->data[3], v11)));
                    state->scratch_vector[index01] = c_add(c_add(c_mul(gate->data[4], v00), c_mul(gate->data[5], v01)), 
                                                          c_add(c_mul(gate->data[6], v10), c_mul(gate->data[7], v11)));
                    state->scratch_vector[index10] = c_add(c_add(c_mul(gate->data[8], v00), c_mul(gate->data[9], v01)), 
                                                          c_add(c_mul(gate->data[10], v10), c_mul(gate->data[11], v11)));
                    state->scratch_vector[index11] = c_add(c_add(c_mul(gate->data[12], v00), c_mul(gate->data[13], v01)), 
                                                          c_add(c_mul(gate->data[14], v10), c_mul(gate->data[15], v11)));
                }
            }
        }
        
        for (i = 0; i < size; i++) {
            state->vector[i] = state->scratch_vector[i];
        }
        return;
    }
    
    static long last_uploaded_size = 0;
    if (last_uploaded_size != size) {
        if (!upload_state_to_gpu(state)) {
            long c_bit = 1L << control_qubit;
            long t_bit = 1L << target_qubit;
            long i;
            
            for (i = 0; i < size; i++) {
                if ((i & c_bit) != 0) { 
                    long index00 = i & ~t_bit;
                    long index01 = i | t_bit;
                    long index10 = (i & ~t_bit) | c_bit;
                    long index11 = i;
                    
                    if (index00 < size && index01 < size && index10 < size && index11 < size) {
                        struct t_complex v00 = state->vector[index00];
                        struct t_complex v01 = state->vector[index01];
                        struct t_complex v10 = state->vector[index10];
                        struct t_complex v11 = state->vector[index11];
                        
                        state->scratch_vector[index00] = c_add(c_add(c_mul(gate->data[0], v00), c_mul(gate->data[1], v01)), 
                                                              c_add(c_mul(gate->data[2], v10), c_mul(gate->data[3], v11)));
                        state->scratch_vector[index01] = c_add(c_add(c_mul(gate->data[4], v00), c_mul(gate->data[5], v01)), 
                                                              c_add(c_mul(gate->data[6], v10), c_mul(gate->data[7], v11)));
                        state->scratch_vector[index10] = c_add(c_add(c_mul(gate->data[8], v00), c_mul(gate->data[9], v01)), 
                                                              c_add(c_mul(gate->data[10], v10), c_mul(gate->data[11], v11)));
                        state->scratch_vector[index11] = c_add(c_add(c_mul(gate->data[12], v00), c_mul(gate->data[13], v01)), 
                                                              c_add(c_mul(gate->data[14], v10), c_mul(gate->data[15], v11)));
                    }
                }
            }
            
            for (i = 0; i < size; i++) {
                state->vector[i] = state->scratch_vector[i];
            }
            return;
        }
        last_uploaded_size = size;
    }
    
    gate_buf = clCreateBuffer(gpu_context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, 
                             16 * sizeof(struct t_complex), gate->data, &err);
    if (err != CL_SUCCESS) {
        long c_bit = 1L << control_qubit;
        long t_bit = 1L << target_qubit;
        long i;
        
        for (i = 0; i < size; i++) {
            if ((i & c_bit) != 0) { 
                long index00 = i & ~t_bit;
                long index01 = i | t_bit;
                long index10 = (i & ~t_bit) | c_bit;
                long index11 = i;
                
                if (index00 < size && index01 < size && index10 < size && index11 < size) {
                    struct t_complex v00 = state->vector[index00];
                    struct t_complex v01 = state->vector[index01];
                    struct t_complex v10 = state->vector[index10];
                    struct t_complex v11 = state->vector[index11];
                    
                    state->scratch_vector[index00] = c_add(c_add(c_mul(gate->data[0], v00), c_mul(gate->data[1], v01)), 
                                                          c_add(c_mul(gate->data[2], v10), c_mul(gate->data[3], v11)));
                    state->scratch_vector[index01] = c_add(c_add(c_mul(gate->data[4], v00), c_mul(gate->data[5], v01)), 
                                                          c_add(c_mul(gate->data[6], v10), c_mul(gate->data[7], v11)));
                    state->scratch_vector[index10] = c_add(c_add(c_mul(gate->data[8], v00), c_mul(gate->data[9], v01)), 
                                                          c_add(c_mul(gate->data[10], v10), c_mul(gate->data[11], v11)));
                    state->scratch_vector[index11] = c_add(c_add(c_mul(gate->data[12], v00), c_mul(gate->data[13], v01)), 
                                                          c_add(c_mul(gate->data[14], v10), c_mul(gate->data[15], v11)));
                }
            }
        }
        
        for (i = 0; i < size; i++) {
            state->vector[i] = state->scratch_vector[i];
        }
        return;
    }
    
    clSetKernelArg(gate_2q_kernel, 0, sizeof(cl_mem), &persistent_state_buffer);
    clSetKernelArg(gate_2q_kernel, 1, sizeof(cl_mem), &persistent_scratch_buffer);
    clSetKernelArg(gate_2q_kernel, 2, sizeof(cl_mem), &gate_buf);
    clSetKernelArg(gate_2q_kernel, 3, sizeof(int), &control_qubit);
    clSetKernelArg(gate_2q_kernel, 4, sizeof(int), &target_qubit);
    clSetKernelArg(gate_2q_kernel, 5, sizeof(int), &size);
    
    err = clEnqueueNDRangeKernel(gpu_queue, gate_2q_kernel, 1, NULL, &global_size, &local_size, 0, NULL, NULL);
    if (err != CL_SUCCESS) {
        clReleaseMemObject(gate_buf);
        long c_bit = 1L << control_qubit;
        long t_bit = 1L << target_qubit;
        long i;
        
        for (i = 0; i < size; i++) {
            if ((i & c_bit) != 0) { 
                long index00 = i & ~t_bit;
                long index01 = i | t_bit;
                long index10 = (i & ~t_bit) | c_bit;
                long index11 = i;
                
                if (index00 < size && index01 < size && index10 < size && index11 < size) {
                    struct t_complex v00 = state->vector[index00];
                    struct t_complex v01 = state->vector[index01];
                    struct t_complex v10 = state->vector[index10];
                    struct t_complex v11 = state->vector[index11];
                    
                    state->scratch_vector[index00] = c_add(c_add(c_mul(gate->data[0], v00), c_mul(gate->data[1], v01)), 
                                                          c_add(c_mul(gate->data[2], v10), c_mul(gate->data[3], v11)));
                    state->scratch_vector[index01] = c_add(c_add(c_mul(gate->data[4], v00), c_mul(gate->data[5], v01)), 
                                                          c_add(c_mul(gate->data[6], v10), c_mul(gate->data[7], v11)));
                    state->scratch_vector[index10] = c_add(c_add(c_mul(gate->data[8], v00), c_mul(gate->data[9], v01)), 
                                                          c_add(c_mul(gate->data[10], v10), c_mul(gate->data[11], v11)));
                    state->scratch_vector[index11] = c_add(c_add(c_mul(gate->data[12], v00), c_mul(gate->data[13], v01)), 
                                                          c_add(c_mul(gate->data[14], v10), c_mul(gate->data[15], v11)));
                }
            }
        }
        
        for (i = 0; i < size; i++) {
            state->vector[i] = state->scratch_vector[i];
        }
        return;
    }
    
    cl_mem temp = persistent_state_buffer;
    persistent_state_buffer = persistent_scratch_buffer;
    persistent_scratch_buffer = temp;
    
    clReleaseMemObject(gate_buf);
}
#endif

#endif /* QCS_IMPLEMENTATION */
#endif /* QCS_H */
