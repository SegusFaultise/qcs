import os
import re

OUTPUT_FILE = "qcs.h"

AUTHOR = "SegusFaultise / Zakk Wilson-Christian"
DATE = "2025-10-06"
LICENSE = """
/*
 * The MIT License (MIT)
 * * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
"""

SRC_FILES = [
    "src/complex.c",
    "src/q_utils.c",
    "src/q_matrix.c",
    "src/q_state.c",
    "src/qcs.c",
    "src/thread_pools.c",
    "src/q_gates.c",
]

GPU_SRC_FILES = [
    "src/gpu_complex.c",
]

API_HEADERS = [
    "src/internal.h",
    "include/qcs.h",
]

EXCLUDE_INCLUDES = [
    '#include "internal.h"',
    '#include "qcs.h"',
    '#include "../include/qcs.h"',
    '#include <math.h>',
    '#include <stdio.h>',
    '#include <stdlib.h>',
    '#include <string.h>',
    '#include <unistd.h>',
    '#include <sys/time.h>',
    '#include <time.h>',
    '#include <stddef.h>',
]


def clean_content(content, filename):
    """Clean content by removing internal includes and fixing comments."""
    
    content = re.sub(r'(?<![:/])//', r'/*', content)
    
    lines = content.splitlines()
    cleaned_lines = []
    
    for line in lines:
        stripped_line = line.strip()
        
        if stripped_line in EXCLUDE_INCLUDES:
            continue
            
        if not stripped_line and not any(l.strip() for l in cleaned_lines if l.strip()):
            continue
            
        cleaned_lines.append(line)
    
    return '\n'.join(cleaned_lines)


def get_header_api(filename):
    """Extract declarations and structs from header files."""
    try:
        with open(filename, 'r') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"Error: Header file not found at {filename}")
        return ""

    content = re.sub(r'#ifndef\s+\w+\n', '', content)
    content = re.sub(r'#define\s+\w+\n', '', content)
    content = re.sub(r'#endif\s*.*', '', content)

    content = content.replace(
        "struct __attribute__((aligned(64))) t_q_matrix", "struct t_q_matrix")
    
    for inc in EXCLUDE_INCLUDES:
        content = content.replace(inc, '')

    return content


def process_gpu_content(content):
    """Process GPU content and add proper guards."""
    content = re.sub(
        r'#include <CL/cl\.h>',
        r'#ifdef QCS_GPU_OPENCL\n#include <CL/cl.h>\n#endif',
        content
    )
    
    content = re.sub(
        r'/\* GPU-accelerated bulk operations using OpenMP GPU offloading \*/\n#if GPU_AVAILABLE.*?#endif',
        r'/* OpenMP GPU functions removed - using OpenCL instead */',
        content,
        flags=re.DOTALL
    )
    
    content = '#ifdef QCS_GPU_OPENCL\n' + content + '\n#endif'
    
    return content


def bundle_library():
    """Generate qcs.h single header library with all parallelization modes."""
    print(f"Starting bundle process. Output: {OUTPUT_FILE}")

    output = f"""
/*
 * Quantum Computing Simulator (QCS) - Single Header Library
 *
 * File: {OUTPUT_FILE}
 * Generated: {DATE}
 * Author: {AUTHOR}
 * Auto-Generated by bundle.py
 * 
 * PARALLELIZATION MODE SELECTION:
 * 
 * QCS is sequential by default for maximum compatibility and simplicity.
 * 
 * To enable parallelization, define one of the following BEFORE including qcs.h:
 * 
 * #define QCS_MULTI_THREAD    - Use pthread threads for parallelization
 * #define QCS_CPU_OPENMP      - Use OpenMP parallel loops
 * #define QCS_GPU_OPENCL      - Use OpenCL GPU acceleration
 * #define QCS_SIMD_ONLY       - Use SIMD vectorization only
 * 
 * Example usage:
 * #define QCS_GPU_OPENCL
 * #define QCS_IMPLEMENTATION
 * #include "qcs.h"
 * 
 * If no parallelization mode is defined, QCS runs in pure sequential mode
 * with no parallelization overhead.
 */
{LICENSE}

#ifndef QCS_H
#define QCS_H

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/time.h>
#include <time.h>

/* ========================================================================= */
/* API FUNCTION DECLARATIONS AND STRUCTURES (from internal.h and qcs.h)      */
/* ========================================================================= */

"""

    for h_file in API_HEADERS:
        print(f"  - Reading API from {h_file}...")
        output += get_header_api(h_file)

    output += """

/* ========================================================================= */
/* IMPLEMENTATION (Define QCS_IMPLEMENTATION in ONE C source file to include */
/* definitions)                                                              */
/* ========================================================================= */
#ifdef QCS_IMPLEMENTATION

/* Forward declarations for worker functions */
#ifdef QCS_MULTI_THREAD
static void q_apply_1q_gate_worker(void *arg);
static void q_apply_2q_gate_worker(void *arg);
#endif

"""

    for c_file in SRC_FILES:
        print(f"  - Reading implementation from {c_file}...")
        try:
            with open(c_file, 'r') as f:
                content = f.read()
        except FileNotFoundError:
            print(f"Error: Source file not found at {c_file}")
            continue

        output += f"\n/* ------------------------------------------------------------------------- */\n"
        output += f"/* {os.path.basename(c_file)} implementation                                         */\n"
        output += f"/* ------------------------------------------------------------------------- */\n\n"

        cleaned_content = clean_content(content, c_file)
        output += cleaned_content

    for c_file in GPU_SRC_FILES:
        print(f"  - Reading GPU implementation from {c_file}...")
        try:
            with open(c_file, 'r') as f:
                content = f.read()
        except FileNotFoundError:
            print(f"Error: GPU source file not found at {c_file}")
            continue

        output += f"\n/* ------------------------------------------------------------------------- */\n"
        output += f"/* {os.path.basename(c_file)} implementation (GPU)                                */\n"
        output += f"/* ------------------------------------------------------------------------- */\n\n"

        cleaned_content = clean_content(content, c_file)
        gpu_content = process_gpu_content(cleaned_content)
        output += gpu_content

    output += """

#endif /* QCS_IMPLEMENTATION */
#endif /* QCS_H */
"""

    with open(OUTPUT_FILE, 'w') as f:
        f.write(output)

    print(f"\nGenerated qcs single header library: {OUTPUT_FILE}")
    print(f"Contains all parallelization modes - select with preprocessor definitions")
    print(f"To use: #define QCS_IMPLEMENTATION before including this header")


if __name__ == "__main__":
    bundle_library()
